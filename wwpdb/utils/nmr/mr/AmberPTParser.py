# Generated from AmberPTParser.g4 by ANTLR 4.10.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,74,643,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,1,0,1,0,3,0,103,8,0,1,0,1,0,1,
        0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
        0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
        0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,5,0,152,8,0,10,
        0,12,0,155,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,167,8,
        1,1,1,1,1,1,2,1,2,1,2,5,2,174,8,2,10,2,12,2,177,9,2,1,2,1,2,1,3,
        1,3,1,3,5,3,184,8,3,10,3,12,3,187,9,3,1,3,1,3,1,4,1,4,1,4,5,4,194,
        8,4,10,4,12,4,197,9,4,1,4,1,4,1,5,1,5,1,5,5,5,204,8,5,10,5,12,5,
        207,9,5,1,5,1,5,1,6,1,6,1,6,5,6,214,8,6,10,6,12,6,217,9,6,1,6,1,
        6,1,7,1,7,1,7,5,7,224,8,7,10,7,12,7,227,9,7,1,7,1,7,1,8,1,8,1,8,
        5,8,234,8,8,10,8,12,8,237,9,8,1,8,1,8,1,9,1,9,1,9,5,9,244,8,9,10,
        9,12,9,247,9,9,1,9,1,9,1,10,1,10,1,10,5,10,254,8,10,10,10,12,10,
        257,9,10,1,10,1,10,1,11,1,11,1,11,5,11,264,8,11,10,11,12,11,267,
        9,11,1,11,1,11,1,12,1,12,1,12,5,12,274,8,12,10,12,12,12,277,9,12,
        1,12,1,12,1,13,1,13,1,13,5,13,284,8,13,10,13,12,13,287,9,13,1,13,
        1,13,1,14,1,14,1,14,5,14,294,8,14,10,14,12,14,297,9,14,1,14,1,14,
        1,15,1,15,1,15,5,15,304,8,15,10,15,12,15,307,9,15,1,15,1,15,1,16,
        1,16,1,16,5,16,314,8,16,10,16,12,16,317,9,16,1,16,1,16,1,17,1,17,
        1,17,5,17,324,8,17,10,17,12,17,327,9,17,1,17,1,17,1,18,1,18,1,18,
        5,18,334,8,18,10,18,12,18,337,9,18,1,18,1,18,1,19,1,19,1,19,5,19,
        344,8,19,10,19,12,19,347,9,19,1,19,1,19,1,20,1,20,1,20,5,20,354,
        8,20,10,20,12,20,357,9,20,1,20,1,20,1,21,1,21,1,21,5,21,364,8,21,
        10,21,12,21,367,9,21,1,21,1,21,1,22,1,22,1,22,5,22,374,8,22,10,22,
        12,22,377,9,22,1,22,1,22,1,23,1,23,1,23,5,23,384,8,23,10,23,12,23,
        387,9,23,1,23,1,23,1,24,1,24,1,24,5,24,394,8,24,10,24,12,24,397,
        9,24,1,24,1,24,1,25,1,25,1,25,5,25,404,8,25,10,25,12,25,407,9,25,
        1,25,1,25,1,26,1,26,1,26,5,26,414,8,26,10,26,12,26,417,9,26,1,26,
        1,26,1,27,1,27,1,27,5,27,424,8,27,10,27,12,27,427,9,27,1,27,1,27,
        1,28,1,28,1,28,5,28,434,8,28,10,28,12,28,437,9,28,1,28,1,28,1,29,
        1,29,1,29,5,29,444,8,29,10,29,12,29,447,9,29,1,29,1,29,1,30,1,30,
        1,30,5,30,454,8,30,10,30,12,30,457,9,30,1,30,1,30,1,31,1,31,1,31,
        5,31,464,8,31,10,31,12,31,467,9,31,1,31,1,31,1,32,1,32,1,32,5,32,
        474,8,32,10,32,12,32,477,9,32,1,32,1,32,1,33,1,33,1,33,5,33,484,
        8,33,10,33,12,33,487,9,33,1,33,1,33,1,34,1,34,1,34,5,34,494,8,34,
        10,34,12,34,497,9,34,1,34,1,34,1,35,1,35,1,35,5,35,504,8,35,10,35,
        12,35,507,9,35,1,35,1,35,1,36,1,36,1,36,5,36,514,8,36,10,36,12,36,
        517,9,36,1,36,1,36,1,37,1,37,1,37,5,37,524,8,37,10,37,12,37,527,
        9,37,1,37,1,37,1,38,1,38,1,38,5,38,534,8,38,10,38,12,38,537,9,38,
        1,38,1,38,1,39,1,39,1,39,5,39,544,8,39,10,39,12,39,547,9,39,1,39,
        1,39,1,40,1,40,1,40,5,40,554,8,40,10,40,12,40,557,9,40,1,40,1,40,
        1,41,1,41,1,41,4,41,564,8,41,11,41,12,41,565,1,41,1,41,1,42,1,42,
        1,42,5,42,573,8,42,10,42,12,42,576,9,42,1,42,1,42,1,43,1,43,1,43,
        5,43,583,8,43,10,43,12,43,586,9,43,1,43,1,43,1,44,1,44,1,44,5,44,
        593,8,44,10,44,12,44,596,9,44,1,44,1,44,1,45,1,45,1,45,5,45,603,
        8,45,10,45,12,45,606,9,45,1,45,1,45,1,46,1,46,1,46,5,46,613,8,46,
        10,46,12,46,616,9,46,1,46,1,46,1,47,1,47,1,47,5,47,623,8,47,10,47,
        12,47,626,9,47,1,47,1,47,1,48,1,48,1,48,5,48,633,8,48,10,48,12,48,
        636,9,48,1,48,1,48,1,49,1,49,1,49,1,49,0,0,50,0,2,4,6,8,10,12,14,
        16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
        60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,0,5,
        1,1,62,62,1,1,68,68,1,1,74,74,1,1,71,71,1,0,63,65,688,0,102,1,0,
        0,0,2,158,1,0,0,0,4,170,1,0,0,0,6,180,1,0,0,0,8,190,1,0,0,0,10,200,
        1,0,0,0,12,210,1,0,0,0,14,220,1,0,0,0,16,230,1,0,0,0,18,240,1,0,
        0,0,20,250,1,0,0,0,22,260,1,0,0,0,24,270,1,0,0,0,26,280,1,0,0,0,
        28,290,1,0,0,0,30,300,1,0,0,0,32,310,1,0,0,0,34,320,1,0,0,0,36,330,
        1,0,0,0,38,340,1,0,0,0,40,350,1,0,0,0,42,360,1,0,0,0,44,370,1,0,
        0,0,46,380,1,0,0,0,48,390,1,0,0,0,50,400,1,0,0,0,52,410,1,0,0,0,
        54,420,1,0,0,0,56,430,1,0,0,0,58,440,1,0,0,0,60,450,1,0,0,0,62,460,
        1,0,0,0,64,470,1,0,0,0,66,480,1,0,0,0,68,490,1,0,0,0,70,500,1,0,
        0,0,72,510,1,0,0,0,74,520,1,0,0,0,76,530,1,0,0,0,78,540,1,0,0,0,
        80,550,1,0,0,0,82,560,1,0,0,0,84,569,1,0,0,0,86,579,1,0,0,0,88,589,
        1,0,0,0,90,599,1,0,0,0,92,609,1,0,0,0,94,619,1,0,0,0,96,629,1,0,
        0,0,98,639,1,0,0,0,100,103,3,2,1,0,101,103,5,2,0,0,102,100,1,0,0,
        0,102,101,1,0,0,0,103,153,1,0,0,0,104,152,3,4,2,0,105,152,3,6,3,
        0,106,152,3,8,4,0,107,152,3,10,5,0,108,152,3,12,6,0,109,152,3,14,
        7,0,110,152,3,16,8,0,111,152,3,18,9,0,112,152,3,20,10,0,113,152,
        3,22,11,0,114,152,3,24,12,0,115,152,3,26,13,0,116,152,3,28,14,0,
        117,152,3,30,15,0,118,152,3,32,16,0,119,152,3,34,17,0,120,152,3,
        36,18,0,121,152,3,38,19,0,122,152,3,40,20,0,123,152,3,42,21,0,124,
        152,3,44,22,0,125,152,3,46,23,0,126,152,3,48,24,0,127,152,3,50,25,
        0,128,152,3,52,26,0,129,152,3,54,27,0,130,152,3,56,28,0,131,152,
        3,58,29,0,132,152,3,60,30,0,133,152,3,62,31,0,134,152,3,64,32,0,
        135,152,3,66,33,0,136,152,3,68,34,0,137,152,3,70,35,0,138,152,3,
        72,36,0,139,152,3,74,37,0,140,152,3,76,38,0,141,152,3,78,39,0,142,
        152,3,80,40,0,143,152,3,82,41,0,144,152,3,84,42,0,145,152,3,86,43,
        0,146,152,3,88,44,0,147,152,3,90,45,0,148,152,3,92,46,0,149,152,
        3,94,47,0,150,152,3,96,48,0,151,104,1,0,0,0,151,105,1,0,0,0,151,
        106,1,0,0,0,151,107,1,0,0,0,151,108,1,0,0,0,151,109,1,0,0,0,151,
        110,1,0,0,0,151,111,1,0,0,0,151,112,1,0,0,0,151,113,1,0,0,0,151,
        114,1,0,0,0,151,115,1,0,0,0,151,116,1,0,0,0,151,117,1,0,0,0,151,
        118,1,0,0,0,151,119,1,0,0,0,151,120,1,0,0,0,151,121,1,0,0,0,151,
        122,1,0,0,0,151,123,1,0,0,0,151,124,1,0,0,0,151,125,1,0,0,0,151,
        126,1,0,0,0,151,127,1,0,0,0,151,128,1,0,0,0,151,129,1,0,0,0,151,
        130,1,0,0,0,151,131,1,0,0,0,151,132,1,0,0,0,151,133,1,0,0,0,151,
        134,1,0,0,0,151,135,1,0,0,0,151,136,1,0,0,0,151,137,1,0,0,0,151,
        138,1,0,0,0,151,139,1,0,0,0,151,140,1,0,0,0,151,141,1,0,0,0,151,
        142,1,0,0,0,151,143,1,0,0,0,151,144,1,0,0,0,151,145,1,0,0,0,151,
        146,1,0,0,0,151,147,1,0,0,0,151,148,1,0,0,0,151,149,1,0,0,0,151,
        150,1,0,0,0,152,155,1,0,0,0,153,151,1,0,0,0,153,154,1,0,0,0,154,
        156,1,0,0,0,155,153,1,0,0,0,156,157,5,0,0,1,157,1,1,0,0,0,158,159,
        5,1,0,0,159,160,5,56,0,0,160,161,5,58,0,0,161,162,5,59,0,0,162,163,
        5,57,0,0,163,164,5,58,0,0,164,166,5,60,0,0,165,167,5,60,0,0,166,
        165,1,0,0,0,166,167,1,0,0,0,167,168,1,0,0,0,168,169,7,0,0,0,169,
        3,1,0,0,0,170,171,5,3,0,0,171,175,3,98,49,0,172,174,5,66,0,0,173,
        172,1,0,0,0,174,177,1,0,0,0,175,173,1,0,0,0,175,176,1,0,0,0,176,
        178,1,0,0,0,177,175,1,0,0,0,178,179,7,1,0,0,179,5,1,0,0,0,180,181,
        5,4,0,0,181,185,3,98,49,0,182,184,5,72,0,0,183,182,1,0,0,0,184,187,
        1,0,0,0,185,183,1,0,0,0,185,186,1,0,0,0,186,188,1,0,0,0,187,185,
        1,0,0,0,188,189,7,2,0,0,189,7,1,0,0,0,190,191,5,5,0,0,191,195,3,
        98,49,0,192,194,5,72,0,0,193,192,1,0,0,0,194,197,1,0,0,0,195,193,
        1,0,0,0,195,196,1,0,0,0,196,198,1,0,0,0,197,195,1,0,0,0,198,199,
        7,2,0,0,199,9,1,0,0,0,200,201,5,6,0,0,201,205,3,98,49,0,202,204,
        5,69,0,0,203,202,1,0,0,0,204,207,1,0,0,0,205,203,1,0,0,0,205,206,
        1,0,0,0,206,208,1,0,0,0,207,205,1,0,0,0,208,209,7,3,0,0,209,11,1,
        0,0,0,210,211,5,7,0,0,211,215,3,98,49,0,212,214,5,69,0,0,213,212,
        1,0,0,0,214,217,1,0,0,0,215,213,1,0,0,0,215,216,1,0,0,0,216,218,
        1,0,0,0,217,215,1,0,0,0,218,219,7,3,0,0,219,13,1,0,0,0,220,221,5,
        8,0,0,221,225,3,98,49,0,222,224,5,69,0,0,223,222,1,0,0,0,224,227,
        1,0,0,0,225,223,1,0,0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,225,
        1,0,0,0,228,229,7,3,0,0,229,15,1,0,0,0,230,231,5,9,0,0,231,235,3,
        98,49,0,232,234,5,66,0,0,233,232,1,0,0,0,234,237,1,0,0,0,235,233,
        1,0,0,0,235,236,1,0,0,0,236,238,1,0,0,0,237,235,1,0,0,0,238,239,
        7,1,0,0,239,17,1,0,0,0,240,241,5,10,0,0,241,245,3,98,49,0,242,244,
        5,69,0,0,243,242,1,0,0,0,244,247,1,0,0,0,245,243,1,0,0,0,245,246,
        1,0,0,0,246,248,1,0,0,0,247,245,1,0,0,0,248,249,7,3,0,0,249,19,1,
        0,0,0,250,251,5,11,0,0,251,255,3,98,49,0,252,254,5,69,0,0,253,252,
        1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,255,256,1,0,0,0,256,258,
        1,0,0,0,257,255,1,0,0,0,258,259,7,3,0,0,259,21,1,0,0,0,260,261,5,
        12,0,0,261,265,3,98,49,0,262,264,5,72,0,0,263,262,1,0,0,0,264,267,
        1,0,0,0,265,263,1,0,0,0,265,266,1,0,0,0,266,268,1,0,0,0,267,265,
        1,0,0,0,268,269,7,2,0,0,269,23,1,0,0,0,270,271,5,13,0,0,271,275,
        3,98,49,0,272,274,5,72,0,0,273,272,1,0,0,0,274,277,1,0,0,0,275,273,
        1,0,0,0,275,276,1,0,0,0,276,278,1,0,0,0,277,275,1,0,0,0,278,279,
        7,2,0,0,279,25,1,0,0,0,280,281,5,14,0,0,281,285,3,98,49,0,282,284,
        5,69,0,0,283,282,1,0,0,0,284,287,1,0,0,0,285,283,1,0,0,0,285,286,
        1,0,0,0,286,288,1,0,0,0,287,285,1,0,0,0,288,289,7,3,0,0,289,27,1,
        0,0,0,290,291,5,15,0,0,291,295,3,98,49,0,292,294,5,69,0,0,293,292,
        1,0,0,0,294,297,1,0,0,0,295,293,1,0,0,0,295,296,1,0,0,0,296,298,
        1,0,0,0,297,295,1,0,0,0,298,299,7,3,0,0,299,29,1,0,0,0,300,301,5,
        16,0,0,301,305,3,98,49,0,302,304,5,72,0,0,303,302,1,0,0,0,304,307,
        1,0,0,0,305,303,1,0,0,0,305,306,1,0,0,0,306,308,1,0,0,0,307,305,
        1,0,0,0,308,309,7,2,0,0,309,31,1,0,0,0,310,311,5,17,0,0,311,315,
        3,98,49,0,312,314,5,69,0,0,313,312,1,0,0,0,314,317,1,0,0,0,315,313,
        1,0,0,0,315,316,1,0,0,0,316,318,1,0,0,0,317,315,1,0,0,0,318,319,
        7,3,0,0,319,33,1,0,0,0,320,321,5,18,0,0,321,325,3,98,49,0,322,324,
        5,72,0,0,323,322,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,0,325,326,
        1,0,0,0,326,328,1,0,0,0,327,325,1,0,0,0,328,329,7,2,0,0,329,35,1,
        0,0,0,330,331,5,19,0,0,331,335,3,98,49,0,332,334,5,72,0,0,333,332,
        1,0,0,0,334,337,1,0,0,0,335,333,1,0,0,0,335,336,1,0,0,0,336,338,
        1,0,0,0,337,335,1,0,0,0,338,339,7,2,0,0,339,37,1,0,0,0,340,341,5,
        20,0,0,341,345,3,98,49,0,342,344,5,72,0,0,343,342,1,0,0,0,344,347,
        1,0,0,0,345,343,1,0,0,0,345,346,1,0,0,0,346,348,1,0,0,0,347,345,
        1,0,0,0,348,349,7,2,0,0,349,39,1,0,0,0,350,351,5,21,0,0,351,355,
        3,98,49,0,352,354,5,72,0,0,353,352,1,0,0,0,354,357,1,0,0,0,355,353,
        1,0,0,0,355,356,1,0,0,0,356,358,1,0,0,0,357,355,1,0,0,0,358,359,
        7,2,0,0,359,41,1,0,0,0,360,361,5,22,0,0,361,365,3,98,49,0,362,364,
        5,72,0,0,363,362,1,0,0,0,364,367,1,0,0,0,365,363,1,0,0,0,365,366,
        1,0,0,0,366,368,1,0,0,0,367,365,1,0,0,0,368,369,7,2,0,0,369,43,1,
        0,0,0,370,371,5,23,0,0,371,375,3,98,49,0,372,374,5,69,0,0,373,372,
        1,0,0,0,374,377,1,0,0,0,375,373,1,0,0,0,375,376,1,0,0,0,376,378,
        1,0,0,0,377,375,1,0,0,0,378,379,7,3,0,0,379,45,1,0,0,0,380,381,5,
        24,0,0,381,385,3,98,49,0,382,384,5,69,0,0,383,382,1,0,0,0,384,387,
        1,0,0,0,385,383,1,0,0,0,385,386,1,0,0,0,386,388,1,0,0,0,387,385,
        1,0,0,0,388,389,7,3,0,0,389,47,1,0,0,0,390,391,5,25,0,0,391,395,
        3,98,49,0,392,394,5,69,0,0,393,392,1,0,0,0,394,397,1,0,0,0,395,393,
        1,0,0,0,395,396,1,0,0,0,396,398,1,0,0,0,397,395,1,0,0,0,398,399,
        7,3,0,0,399,49,1,0,0,0,400,401,5,26,0,0,401,405,3,98,49,0,402,404,
        5,72,0,0,403,402,1,0,0,0,404,407,1,0,0,0,405,403,1,0,0,0,405,406,
        1,0,0,0,406,408,1,0,0,0,407,405,1,0,0,0,408,409,7,2,0,0,409,51,1,
        0,0,0,410,411,5,27,0,0,411,415,3,98,49,0,412,414,5,72,0,0,413,412,
        1,0,0,0,414,417,1,0,0,0,415,413,1,0,0,0,415,416,1,0,0,0,416,418,
        1,0,0,0,417,415,1,0,0,0,418,419,7,2,0,0,419,53,1,0,0,0,420,421,5,
        28,0,0,421,425,3,98,49,0,422,424,5,72,0,0,423,422,1,0,0,0,424,427,
        1,0,0,0,425,423,1,0,0,0,425,426,1,0,0,0,426,428,1,0,0,0,427,425,
        1,0,0,0,428,429,7,2,0,0,429,55,1,0,0,0,430,431,5,29,0,0,431,435,
        3,98,49,0,432,434,5,69,0,0,433,432,1,0,0,0,434,437,1,0,0,0,435,433,
        1,0,0,0,435,436,1,0,0,0,436,438,1,0,0,0,437,435,1,0,0,0,438,439,
        7,3,0,0,439,57,1,0,0,0,440,441,5,30,0,0,441,445,3,98,49,0,442,444,
        5,69,0,0,443,442,1,0,0,0,444,447,1,0,0,0,445,443,1,0,0,0,445,446,
        1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,449,7,3,0,0,449,59,1,
        0,0,0,450,451,5,31,0,0,451,455,3,98,49,0,452,454,5,69,0,0,453,452,
        1,0,0,0,454,457,1,0,0,0,455,453,1,0,0,0,455,456,1,0,0,0,456,458,
        1,0,0,0,457,455,1,0,0,0,458,459,7,3,0,0,459,61,1,0,0,0,460,461,5,
        32,0,0,461,465,3,98,49,0,462,464,5,72,0,0,463,462,1,0,0,0,464,467,
        1,0,0,0,465,463,1,0,0,0,465,466,1,0,0,0,466,468,1,0,0,0,467,465,
        1,0,0,0,468,469,7,2,0,0,469,63,1,0,0,0,470,471,5,33,0,0,471,475,
        3,98,49,0,472,474,5,72,0,0,473,472,1,0,0,0,474,477,1,0,0,0,475,473,
        1,0,0,0,475,476,1,0,0,0,476,478,1,0,0,0,477,475,1,0,0,0,478,479,
        7,2,0,0,479,65,1,0,0,0,480,481,5,34,0,0,481,485,3,98,49,0,482,484,
        5,72,0,0,483,482,1,0,0,0,484,487,1,0,0,0,485,483,1,0,0,0,485,486,
        1,0,0,0,486,488,1,0,0,0,487,485,1,0,0,0,488,489,7,2,0,0,489,67,1,
        0,0,0,490,491,5,35,0,0,491,495,3,98,49,0,492,494,5,69,0,0,493,492,
        1,0,0,0,494,497,1,0,0,0,495,493,1,0,0,0,495,496,1,0,0,0,496,498,
        1,0,0,0,497,495,1,0,0,0,498,499,7,3,0,0,499,69,1,0,0,0,500,501,5,
        36,0,0,501,505,3,98,49,0,502,504,5,69,0,0,503,502,1,0,0,0,504,507,
        1,0,0,0,505,503,1,0,0,0,505,506,1,0,0,0,506,508,1,0,0,0,507,505,
        1,0,0,0,508,509,7,3,0,0,509,71,1,0,0,0,510,511,5,37,0,0,511,515,
        3,98,49,0,512,514,5,69,0,0,513,512,1,0,0,0,514,517,1,0,0,0,515,513,
        1,0,0,0,515,516,1,0,0,0,516,518,1,0,0,0,517,515,1,0,0,0,518,519,
        7,3,0,0,519,73,1,0,0,0,520,521,5,38,0,0,521,525,3,98,49,0,522,524,
        5,72,0,0,523,522,1,0,0,0,524,527,1,0,0,0,525,523,1,0,0,0,525,526,
        1,0,0,0,526,528,1,0,0,0,527,525,1,0,0,0,528,529,7,2,0,0,529,75,1,
        0,0,0,530,531,5,39,0,0,531,535,3,98,49,0,532,534,5,72,0,0,533,532,
        1,0,0,0,534,537,1,0,0,0,535,533,1,0,0,0,535,536,1,0,0,0,536,538,
        1,0,0,0,537,535,1,0,0,0,538,539,7,2,0,0,539,77,1,0,0,0,540,541,5,
        40,0,0,541,545,3,98,49,0,542,544,5,66,0,0,543,542,1,0,0,0,544,547,
        1,0,0,0,545,543,1,0,0,0,545,546,1,0,0,0,546,548,1,0,0,0,547,545,
        1,0,0,0,548,549,7,1,0,0,549,79,1,0,0,0,550,551,5,41,0,0,551,555,
        3,98,49,0,552,554,5,66,0,0,553,552,1,0,0,0,554,557,1,0,0,0,555,553,
        1,0,0,0,555,556,1,0,0,0,556,558,1,0,0,0,557,555,1,0,0,0,558,559,
        7,1,0,0,559,81,1,0,0,0,560,561,5,42,0,0,561,563,3,98,49,0,562,564,
        5,69,0,0,563,562,1,0,0,0,564,565,1,0,0,0,565,563,1,0,0,0,565,566,
        1,0,0,0,566,567,1,0,0,0,567,568,7,3,0,0,568,83,1,0,0,0,569,570,5,
        43,0,0,570,574,3,98,49,0,571,573,5,72,0,0,572,571,1,0,0,0,573,576,
        1,0,0,0,574,572,1,0,0,0,574,575,1,0,0,0,575,577,1,0,0,0,576,574,
        1,0,0,0,577,578,7,2,0,0,578,85,1,0,0,0,579,580,5,44,0,0,580,584,
        3,98,49,0,581,583,5,72,0,0,582,581,1,0,0,0,583,586,1,0,0,0,584,582,
        1,0,0,0,584,585,1,0,0,0,585,587,1,0,0,0,586,584,1,0,0,0,587,588,
        7,2,0,0,588,87,1,0,0,0,589,590,5,45,0,0,590,594,3,98,49,0,591,593,
        5,72,0,0,592,591,1,0,0,0,593,596,1,0,0,0,594,592,1,0,0,0,594,595,
        1,0,0,0,595,597,1,0,0,0,596,594,1,0,0,0,597,598,7,2,0,0,598,89,1,
        0,0,0,599,600,5,46,0,0,600,604,3,98,49,0,601,603,5,72,0,0,602,601,
        1,0,0,0,603,606,1,0,0,0,604,602,1,0,0,0,604,605,1,0,0,0,605,607,
        1,0,0,0,606,604,1,0,0,0,607,608,7,2,0,0,608,91,1,0,0,0,609,610,5,
        47,0,0,610,614,3,98,49,0,611,613,5,69,0,0,612,611,1,0,0,0,613,616,
        1,0,0,0,614,612,1,0,0,0,614,615,1,0,0,0,615,617,1,0,0,0,616,614,
        1,0,0,0,617,618,7,3,0,0,618,93,1,0,0,0,619,620,5,48,0,0,620,624,
        3,98,49,0,621,623,5,66,0,0,622,621,1,0,0,0,623,626,1,0,0,0,624,622,
        1,0,0,0,624,625,1,0,0,0,625,627,1,0,0,0,626,624,1,0,0,0,627,628,
        7,1,0,0,628,95,1,0,0,0,629,630,5,49,0,0,630,634,3,98,49,0,631,633,
        5,66,0,0,632,631,1,0,0,0,633,636,1,0,0,0,634,632,1,0,0,0,634,635,
        1,0,0,0,635,637,1,0,0,0,636,634,1,0,0,0,637,638,7,1,0,0,638,97,1,
        0,0,0,639,640,5,53,0,0,640,641,7,4,0,0,641,99,1,0,0,0,51,102,151,
        153,166,175,185,195,205,215,225,235,245,255,265,275,285,295,305,
        315,325,335,345,355,365,375,385,395,405,415,425,435,445,455,465,
        475,485,495,505,515,525,535,545,555,565,574,584,594,604,614,624,
        634
    ]

class AmberPTParser ( Parser ):

    grammarFileName = "AmberPTParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'%VERSION'", "<INVALID>", "'AMBER_ATOM_TYPE'", 
                     "'ANGLE_EQUIL_VALUE'", "'ANGLE_FORCE_CONSTANT'", "'ANGLES_INC_HYDROGEN'", 
                     "'ANGLES_WITHOUT_HYDROGEN'", "'ATOMIC_NUMBER'", "'ATOM_NAME'", 
                     "'ATOM_TYPE_INDEX'", "'ATOMS_PER_MOLECULE'", "'BOND_EQUIL_VALUE'", 
                     "'BOND_FORCE_CONSTANT'", "'BONDS_INC_HYDROGEN'", "'BONDS_WITHOUT_HYDROGEN'", 
                     "'BOX_DIMENSIONS'", "'CAP_INFO'", "'CAP_INFO2'", "'CHARGE'", 
                     "'DIHEDRAL_FORCE_CONSTANT'", "'DIHEDRAL_PERIODICITY'", 
                     "'DIHEDRAL_PHASE'", "'DIHEDRALS_INC_HYDROGEN'", "'DIHEDRALS_WITHOUT_HYDROGEN'", 
                     "'EXCLUDED_ATOMS_LIST'", "'HBCUT'", "'HBOND_ACOEF'", 
                     "'HBOND_BCOEF'", "'IPOL'", "'IROTAT'", "'JOIN_ARRAY'", 
                     "'LENNARD_JONES_ACOEF'", "'LENNARD_JONES_BCOEF'", "'MASS'", 
                     "'NONBONDED_PARM_INDEX'", "'NUMBER_EXCLUDED_ATOMS'", 
                     "'POINTERS'", "'POLARIZABILITY'", "'RADII'", "'RADIUS_SET'", 
                     "'RESIDUE_LABEL'", "'RESIDUE_POINTER'", "'SCEE_SCALE_FACTOR'", 
                     "'SCNB_SCALE_FACTOR'", "'SCREEN'", "'SOLTY'", "'SOLVENT_POINTERS'", 
                     "'TITLE'", "'TREE_CHAIN_CLASSIFICATION'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'%FORMAT'", "<INVALID>", 
                     "<INVALID>", "'VERSION_STAMP'", "'DATE'", "'='" ]

    symbolicNames = [ "<INVALID>", "VERSION", "FLAG", "AMBER_ATOM_TYPE", 
                      "ANGLE_EQUIL_VALUE", "ANGLE_FORCE_CONSTANT", "ANGLES_INC_HYDROGEN", 
                      "ANGLES_WITHOUT_HYDROGEN", "ATOMIC_NUMBER", "ATOM_NAME", 
                      "ATOM_TYPE_INDEX", "ATOMS_PER_MOLECULE", "BOND_EQUIL_VALUE", 
                      "BOND_FORCE_CONSTANT", "BONDS_INC_HYDROGEN", "BONDS_WITHOUT_HYDROGEN", 
                      "BOX_DIMENSIONS", "CAP_INFO", "CAP_INFO2", "CHARGE", 
                      "DIHEDRAL_FORCE_CONSTANT", "DIHEDRAL_PERIODICITY", 
                      "DIHEDRAL_PHASE", "DIHEDRALS_INC_HYDROGEN", "DIHEDRALS_WITHOUT_HYDROGEN", 
                      "EXCLUDED_ATOMS_LIST", "HBCUT", "HBOND_ACOEF", "HBOND_BCOEF", 
                      "IPOL", "IROTAT", "JOIN_ARRAY", "LENNARD_JONES_ACOEF", 
                      "LENNARD_JONES_BCOEF", "MASS", "NONBONDED_PARM_INDEX", 
                      "NUMBER_EXCLUDED_ATOMS", "POINTERS", "POLARIZABILITY", 
                      "RADII", "RADIUS_SET", "RESIDUE_LABEL", "RESIDUE_POINTER", 
                      "SCEE_SCALE_FACTOR", "SCNB_SCALE_FACTOR", "SCREEN", 
                      "SOLTY", "SOLVENT_POINTERS", "TITLE", "TREE_CHAIN_CLASSIFICATION", 
                      "SHARP_COMMENT", "EXCLM_COMMENT", "SMCLN_COMMENT", 
                      "FORMAT", "SPACE", "LINE_COMMENT", "VERSION_STAMP", 
                      "DATE", "Equ_op", "Version", "Date_time", "SPACE_V", 
                      "FLAG_V", "Fortran_format_A", "Fortran_format_I", 
                      "Fortran_format_E", "Simple_name", "SPACE_A", "FLAG_A", 
                      "Integer", "SPACE_I", "FLAG_I", "Real", "SPACE_E", 
                      "FLAG_E" ]

    RULE_amber_pt = 0
    RULE_version_statement = 1
    RULE_amber_atom_type_statement = 2
    RULE_angle_equil_value_statement = 3
    RULE_angle_force_constant_statement = 4
    RULE_angles_inc_hydrogen_statement = 5
    RULE_angles_without_hydrogen_statement = 6
    RULE_atomic_number_statement = 7
    RULE_atom_name_statement = 8
    RULE_atom_type_index_statement = 9
    RULE_atoms_per_molecule_statement = 10
    RULE_bond_equil_value_statement = 11
    RULE_bond_force_constant_statement = 12
    RULE_bonds_inc_hydrogen_statement = 13
    RULE_bonds_without_hydrogen_statement = 14
    RULE_box_dimensions_statement = 15
    RULE_cap_info_statement = 16
    RULE_cap_info2_statement = 17
    RULE_charge_statement = 18
    RULE_dihedral_force_constant_statement = 19
    RULE_dihedral_periodicity_statement = 20
    RULE_dihedral_phase_statement = 21
    RULE_dihedrals_inc_hydrogen_statement = 22
    RULE_dihedrals_without_hydrogen_statement = 23
    RULE_excluded_atoms_list_statement = 24
    RULE_hbcut_statement = 25
    RULE_hbond_acoef_statement = 26
    RULE_hbond_bcoef_statement = 27
    RULE_ipol_statement = 28
    RULE_irotat_statement = 29
    RULE_join_array_statement = 30
    RULE_lennard_jones_acoef_statement = 31
    RULE_lennard_jones_bcoef_statement = 32
    RULE_mass_statement = 33
    RULE_nonbonded_parm_index_statement = 34
    RULE_number_excluded_atoms_statement = 35
    RULE_pointers_statement = 36
    RULE_polarizability_statement = 37
    RULE_radii_statement = 38
    RULE_radius_set_statement = 39
    RULE_residue_label_statement = 40
    RULE_residue_pointer_statement = 41
    RULE_scee_scale_factor_statement = 42
    RULE_scnb_scale_factor_statement = 43
    RULE_screen_statement = 44
    RULE_solty_statement = 45
    RULE_solvent_pointers_statement = 46
    RULE_title_statement = 47
    RULE_tree_chain_classification_statement = 48
    RULE_format_function = 49

    ruleNames =  [ "amber_pt", "version_statement", "amber_atom_type_statement", 
                   "angle_equil_value_statement", "angle_force_constant_statement", 
                   "angles_inc_hydrogen_statement", "angles_without_hydrogen_statement", 
                   "atomic_number_statement", "atom_name_statement", "atom_type_index_statement", 
                   "atoms_per_molecule_statement", "bond_equil_value_statement", 
                   "bond_force_constant_statement", "bonds_inc_hydrogen_statement", 
                   "bonds_without_hydrogen_statement", "box_dimensions_statement", 
                   "cap_info_statement", "cap_info2_statement", "charge_statement", 
                   "dihedral_force_constant_statement", "dihedral_periodicity_statement", 
                   "dihedral_phase_statement", "dihedrals_inc_hydrogen_statement", 
                   "dihedrals_without_hydrogen_statement", "excluded_atoms_list_statement", 
                   "hbcut_statement", "hbond_acoef_statement", "hbond_bcoef_statement", 
                   "ipol_statement", "irotat_statement", "join_array_statement", 
                   "lennard_jones_acoef_statement", "lennard_jones_bcoef_statement", 
                   "mass_statement", "nonbonded_parm_index_statement", "number_excluded_atoms_statement", 
                   "pointers_statement", "polarizability_statement", "radii_statement", 
                   "radius_set_statement", "residue_label_statement", "residue_pointer_statement", 
                   "scee_scale_factor_statement", "scnb_scale_factor_statement", 
                   "screen_statement", "solty_statement", "solvent_pointers_statement", 
                   "title_statement", "tree_chain_classification_statement", 
                   "format_function" ]

    EOF = Token.EOF
    VERSION=1
    FLAG=2
    AMBER_ATOM_TYPE=3
    ANGLE_EQUIL_VALUE=4
    ANGLE_FORCE_CONSTANT=5
    ANGLES_INC_HYDROGEN=6
    ANGLES_WITHOUT_HYDROGEN=7
    ATOMIC_NUMBER=8
    ATOM_NAME=9
    ATOM_TYPE_INDEX=10
    ATOMS_PER_MOLECULE=11
    BOND_EQUIL_VALUE=12
    BOND_FORCE_CONSTANT=13
    BONDS_INC_HYDROGEN=14
    BONDS_WITHOUT_HYDROGEN=15
    BOX_DIMENSIONS=16
    CAP_INFO=17
    CAP_INFO2=18
    CHARGE=19
    DIHEDRAL_FORCE_CONSTANT=20
    DIHEDRAL_PERIODICITY=21
    DIHEDRAL_PHASE=22
    DIHEDRALS_INC_HYDROGEN=23
    DIHEDRALS_WITHOUT_HYDROGEN=24
    EXCLUDED_ATOMS_LIST=25
    HBCUT=26
    HBOND_ACOEF=27
    HBOND_BCOEF=28
    IPOL=29
    IROTAT=30
    JOIN_ARRAY=31
    LENNARD_JONES_ACOEF=32
    LENNARD_JONES_BCOEF=33
    MASS=34
    NONBONDED_PARM_INDEX=35
    NUMBER_EXCLUDED_ATOMS=36
    POINTERS=37
    POLARIZABILITY=38
    RADII=39
    RADIUS_SET=40
    RESIDUE_LABEL=41
    RESIDUE_POINTER=42
    SCEE_SCALE_FACTOR=43
    SCNB_SCALE_FACTOR=44
    SCREEN=45
    SOLTY=46
    SOLVENT_POINTERS=47
    TITLE=48
    TREE_CHAIN_CLASSIFICATION=49
    SHARP_COMMENT=50
    EXCLM_COMMENT=51
    SMCLN_COMMENT=52
    FORMAT=53
    SPACE=54
    LINE_COMMENT=55
    VERSION_STAMP=56
    DATE=57
    Equ_op=58
    Version=59
    Date_time=60
    SPACE_V=61
    FLAG_V=62
    Fortran_format_A=63
    Fortran_format_I=64
    Fortran_format_E=65
    Simple_name=66
    SPACE_A=67
    FLAG_A=68
    Integer=69
    SPACE_I=70
    FLAG_I=71
    Real=72
    SPACE_E=73
    FLAG_E=74

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.10.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Amber_ptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def version_statement(self):
            return self.getTypedRuleContext(AmberPTParser.Version_statementContext,0)


        def FLAG(self):
            return self.getToken(AmberPTParser.FLAG, 0)

        def amber_atom_type_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Amber_atom_type_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Amber_atom_type_statementContext,i)


        def angle_equil_value_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Angle_equil_value_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Angle_equil_value_statementContext,i)


        def angle_force_constant_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Angle_force_constant_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Angle_force_constant_statementContext,i)


        def angles_inc_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Angles_inc_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Angles_inc_hydrogen_statementContext,i)


        def angles_without_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Angles_without_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Angles_without_hydrogen_statementContext,i)


        def atomic_number_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Atomic_number_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Atomic_number_statementContext,i)


        def atom_name_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Atom_name_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Atom_name_statementContext,i)


        def atom_type_index_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Atom_type_index_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Atom_type_index_statementContext,i)


        def atoms_per_molecule_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Atoms_per_molecule_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Atoms_per_molecule_statementContext,i)


        def bond_equil_value_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Bond_equil_value_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Bond_equil_value_statementContext,i)


        def bond_force_constant_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Bond_force_constant_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Bond_force_constant_statementContext,i)


        def bonds_inc_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Bonds_inc_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Bonds_inc_hydrogen_statementContext,i)


        def bonds_without_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Bonds_without_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Bonds_without_hydrogen_statementContext,i)


        def box_dimensions_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Box_dimensions_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Box_dimensions_statementContext,i)


        def cap_info_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Cap_info_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Cap_info_statementContext,i)


        def cap_info2_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Cap_info2_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Cap_info2_statementContext,i)


        def charge_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Charge_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Charge_statementContext,i)


        def dihedral_force_constant_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Dihedral_force_constant_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Dihedral_force_constant_statementContext,i)


        def dihedral_periodicity_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Dihedral_periodicity_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Dihedral_periodicity_statementContext,i)


        def dihedral_phase_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Dihedral_phase_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Dihedral_phase_statementContext,i)


        def dihedrals_inc_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Dihedrals_inc_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Dihedrals_inc_hydrogen_statementContext,i)


        def dihedrals_without_hydrogen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Dihedrals_without_hydrogen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Dihedrals_without_hydrogen_statementContext,i)


        def excluded_atoms_list_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Excluded_atoms_list_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Excluded_atoms_list_statementContext,i)


        def hbcut_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Hbcut_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Hbcut_statementContext,i)


        def hbond_acoef_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Hbond_acoef_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Hbond_acoef_statementContext,i)


        def hbond_bcoef_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Hbond_bcoef_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Hbond_bcoef_statementContext,i)


        def ipol_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Ipol_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Ipol_statementContext,i)


        def irotat_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Irotat_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Irotat_statementContext,i)


        def join_array_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Join_array_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Join_array_statementContext,i)


        def lennard_jones_acoef_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Lennard_jones_acoef_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Lennard_jones_acoef_statementContext,i)


        def lennard_jones_bcoef_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Lennard_jones_bcoef_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Lennard_jones_bcoef_statementContext,i)


        def mass_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Mass_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Mass_statementContext,i)


        def nonbonded_parm_index_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Nonbonded_parm_index_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Nonbonded_parm_index_statementContext,i)


        def number_excluded_atoms_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Number_excluded_atoms_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Number_excluded_atoms_statementContext,i)


        def pointers_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Pointers_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Pointers_statementContext,i)


        def polarizability_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Polarizability_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Polarizability_statementContext,i)


        def radii_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Radii_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Radii_statementContext,i)


        def radius_set_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Radius_set_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Radius_set_statementContext,i)


        def residue_label_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Residue_label_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Residue_label_statementContext,i)


        def residue_pointer_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Residue_pointer_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Residue_pointer_statementContext,i)


        def scee_scale_factor_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Scee_scale_factor_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Scee_scale_factor_statementContext,i)


        def scnb_scale_factor_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Scnb_scale_factor_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Scnb_scale_factor_statementContext,i)


        def screen_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Screen_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Screen_statementContext,i)


        def solty_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Solty_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Solty_statementContext,i)


        def solvent_pointers_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Solvent_pointers_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Solvent_pointers_statementContext,i)


        def title_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Title_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Title_statementContext,i)


        def tree_chain_classification_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AmberPTParser.Tree_chain_classification_statementContext)
            else:
                return self.getTypedRuleContext(AmberPTParser.Tree_chain_classification_statementContext,i)


        def getRuleIndex(self):
            return AmberPTParser.RULE_amber_pt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAmber_pt" ):
                listener.enterAmber_pt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAmber_pt" ):
                listener.exitAmber_pt(self)




    def amber_pt(self):

        localctx = AmberPTParser.Amber_ptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_amber_pt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AmberPTParser.VERSION]:
                self.state = 100
                self.version_statement()
                pass
            elif token in [AmberPTParser.FLAG]:
                self.state = 101
                self.match(AmberPTParser.FLAG)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AmberPTParser.AMBER_ATOM_TYPE) | (1 << AmberPTParser.ANGLE_EQUIL_VALUE) | (1 << AmberPTParser.ANGLE_FORCE_CONSTANT) | (1 << AmberPTParser.ANGLES_INC_HYDROGEN) | (1 << AmberPTParser.ANGLES_WITHOUT_HYDROGEN) | (1 << AmberPTParser.ATOMIC_NUMBER) | (1 << AmberPTParser.ATOM_NAME) | (1 << AmberPTParser.ATOM_TYPE_INDEX) | (1 << AmberPTParser.ATOMS_PER_MOLECULE) | (1 << AmberPTParser.BOND_EQUIL_VALUE) | (1 << AmberPTParser.BOND_FORCE_CONSTANT) | (1 << AmberPTParser.BONDS_INC_HYDROGEN) | (1 << AmberPTParser.BONDS_WITHOUT_HYDROGEN) | (1 << AmberPTParser.BOX_DIMENSIONS) | (1 << AmberPTParser.CAP_INFO) | (1 << AmberPTParser.CAP_INFO2) | (1 << AmberPTParser.CHARGE) | (1 << AmberPTParser.DIHEDRAL_FORCE_CONSTANT) | (1 << AmberPTParser.DIHEDRAL_PERIODICITY) | (1 << AmberPTParser.DIHEDRAL_PHASE) | (1 << AmberPTParser.DIHEDRALS_INC_HYDROGEN) | (1 << AmberPTParser.DIHEDRALS_WITHOUT_HYDROGEN) | (1 << AmberPTParser.EXCLUDED_ATOMS_LIST) | (1 << AmberPTParser.HBCUT) | (1 << AmberPTParser.HBOND_ACOEF) | (1 << AmberPTParser.HBOND_BCOEF) | (1 << AmberPTParser.IPOL) | (1 << AmberPTParser.IROTAT) | (1 << AmberPTParser.JOIN_ARRAY) | (1 << AmberPTParser.LENNARD_JONES_ACOEF) | (1 << AmberPTParser.LENNARD_JONES_BCOEF) | (1 << AmberPTParser.MASS) | (1 << AmberPTParser.NONBONDED_PARM_INDEX) | (1 << AmberPTParser.NUMBER_EXCLUDED_ATOMS) | (1 << AmberPTParser.POINTERS) | (1 << AmberPTParser.POLARIZABILITY) | (1 << AmberPTParser.RADII) | (1 << AmberPTParser.RADIUS_SET) | (1 << AmberPTParser.RESIDUE_LABEL) | (1 << AmberPTParser.RESIDUE_POINTER) | (1 << AmberPTParser.SCEE_SCALE_FACTOR) | (1 << AmberPTParser.SCNB_SCALE_FACTOR) | (1 << AmberPTParser.SCREEN) | (1 << AmberPTParser.SOLTY) | (1 << AmberPTParser.SOLVENT_POINTERS) | (1 << AmberPTParser.TITLE) | (1 << AmberPTParser.TREE_CHAIN_CLASSIFICATION))) != 0):
                self.state = 151
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [AmberPTParser.AMBER_ATOM_TYPE]:
                    self.state = 104
                    self.amber_atom_type_statement()
                    pass
                elif token in [AmberPTParser.ANGLE_EQUIL_VALUE]:
                    self.state = 105
                    self.angle_equil_value_statement()
                    pass
                elif token in [AmberPTParser.ANGLE_FORCE_CONSTANT]:
                    self.state = 106
                    self.angle_force_constant_statement()
                    pass
                elif token in [AmberPTParser.ANGLES_INC_HYDROGEN]:
                    self.state = 107
                    self.angles_inc_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.ANGLES_WITHOUT_HYDROGEN]:
                    self.state = 108
                    self.angles_without_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.ATOMIC_NUMBER]:
                    self.state = 109
                    self.atomic_number_statement()
                    pass
                elif token in [AmberPTParser.ATOM_NAME]:
                    self.state = 110
                    self.atom_name_statement()
                    pass
                elif token in [AmberPTParser.ATOM_TYPE_INDEX]:
                    self.state = 111
                    self.atom_type_index_statement()
                    pass
                elif token in [AmberPTParser.ATOMS_PER_MOLECULE]:
                    self.state = 112
                    self.atoms_per_molecule_statement()
                    pass
                elif token in [AmberPTParser.BOND_EQUIL_VALUE]:
                    self.state = 113
                    self.bond_equil_value_statement()
                    pass
                elif token in [AmberPTParser.BOND_FORCE_CONSTANT]:
                    self.state = 114
                    self.bond_force_constant_statement()
                    pass
                elif token in [AmberPTParser.BONDS_INC_HYDROGEN]:
                    self.state = 115
                    self.bonds_inc_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.BONDS_WITHOUT_HYDROGEN]:
                    self.state = 116
                    self.bonds_without_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.BOX_DIMENSIONS]:
                    self.state = 117
                    self.box_dimensions_statement()
                    pass
                elif token in [AmberPTParser.CAP_INFO]:
                    self.state = 118
                    self.cap_info_statement()
                    pass
                elif token in [AmberPTParser.CAP_INFO2]:
                    self.state = 119
                    self.cap_info2_statement()
                    pass
                elif token in [AmberPTParser.CHARGE]:
                    self.state = 120
                    self.charge_statement()
                    pass
                elif token in [AmberPTParser.DIHEDRAL_FORCE_CONSTANT]:
                    self.state = 121
                    self.dihedral_force_constant_statement()
                    pass
                elif token in [AmberPTParser.DIHEDRAL_PERIODICITY]:
                    self.state = 122
                    self.dihedral_periodicity_statement()
                    pass
                elif token in [AmberPTParser.DIHEDRAL_PHASE]:
                    self.state = 123
                    self.dihedral_phase_statement()
                    pass
                elif token in [AmberPTParser.DIHEDRALS_INC_HYDROGEN]:
                    self.state = 124
                    self.dihedrals_inc_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.DIHEDRALS_WITHOUT_HYDROGEN]:
                    self.state = 125
                    self.dihedrals_without_hydrogen_statement()
                    pass
                elif token in [AmberPTParser.EXCLUDED_ATOMS_LIST]:
                    self.state = 126
                    self.excluded_atoms_list_statement()
                    pass
                elif token in [AmberPTParser.HBCUT]:
                    self.state = 127
                    self.hbcut_statement()
                    pass
                elif token in [AmberPTParser.HBOND_ACOEF]:
                    self.state = 128
                    self.hbond_acoef_statement()
                    pass
                elif token in [AmberPTParser.HBOND_BCOEF]:
                    self.state = 129
                    self.hbond_bcoef_statement()
                    pass
                elif token in [AmberPTParser.IPOL]:
                    self.state = 130
                    self.ipol_statement()
                    pass
                elif token in [AmberPTParser.IROTAT]:
                    self.state = 131
                    self.irotat_statement()
                    pass
                elif token in [AmberPTParser.JOIN_ARRAY]:
                    self.state = 132
                    self.join_array_statement()
                    pass
                elif token in [AmberPTParser.LENNARD_JONES_ACOEF]:
                    self.state = 133
                    self.lennard_jones_acoef_statement()
                    pass
                elif token in [AmberPTParser.LENNARD_JONES_BCOEF]:
                    self.state = 134
                    self.lennard_jones_bcoef_statement()
                    pass
                elif token in [AmberPTParser.MASS]:
                    self.state = 135
                    self.mass_statement()
                    pass
                elif token in [AmberPTParser.NONBONDED_PARM_INDEX]:
                    self.state = 136
                    self.nonbonded_parm_index_statement()
                    pass
                elif token in [AmberPTParser.NUMBER_EXCLUDED_ATOMS]:
                    self.state = 137
                    self.number_excluded_atoms_statement()
                    pass
                elif token in [AmberPTParser.POINTERS]:
                    self.state = 138
                    self.pointers_statement()
                    pass
                elif token in [AmberPTParser.POLARIZABILITY]:
                    self.state = 139
                    self.polarizability_statement()
                    pass
                elif token in [AmberPTParser.RADII]:
                    self.state = 140
                    self.radii_statement()
                    pass
                elif token in [AmberPTParser.RADIUS_SET]:
                    self.state = 141
                    self.radius_set_statement()
                    pass
                elif token in [AmberPTParser.RESIDUE_LABEL]:
                    self.state = 142
                    self.residue_label_statement()
                    pass
                elif token in [AmberPTParser.RESIDUE_POINTER]:
                    self.state = 143
                    self.residue_pointer_statement()
                    pass
                elif token in [AmberPTParser.SCEE_SCALE_FACTOR]:
                    self.state = 144
                    self.scee_scale_factor_statement()
                    pass
                elif token in [AmberPTParser.SCNB_SCALE_FACTOR]:
                    self.state = 145
                    self.scnb_scale_factor_statement()
                    pass
                elif token in [AmberPTParser.SCREEN]:
                    self.state = 146
                    self.screen_statement()
                    pass
                elif token in [AmberPTParser.SOLTY]:
                    self.state = 147
                    self.solty_statement()
                    pass
                elif token in [AmberPTParser.SOLVENT_POINTERS]:
                    self.state = 148
                    self.solvent_pointers_statement()
                    pass
                elif token in [AmberPTParser.TITLE]:
                    self.state = 149
                    self.title_statement()
                    pass
                elif token in [AmberPTParser.TREE_CHAIN_CLASSIFICATION]:
                    self.state = 150
                    self.tree_chain_classification_statement()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 155
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 156
            self.match(AmberPTParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Version_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERSION(self):
            return self.getToken(AmberPTParser.VERSION, 0)

        def VERSION_STAMP(self):
            return self.getToken(AmberPTParser.VERSION_STAMP, 0)

        def Equ_op(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Equ_op)
            else:
                return self.getToken(AmberPTParser.Equ_op, i)

        def Version(self):
            return self.getToken(AmberPTParser.Version, 0)

        def DATE(self):
            return self.getToken(AmberPTParser.DATE, 0)

        def Date_time(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Date_time)
            else:
                return self.getToken(AmberPTParser.Date_time, i)

        def FLAG_V(self):
            return self.getToken(AmberPTParser.FLAG_V, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def getRuleIndex(self):
            return AmberPTParser.RULE_version_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersion_statement" ):
                listener.enterVersion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersion_statement" ):
                listener.exitVersion_statement(self)




    def version_statement(self):

        localctx = AmberPTParser.Version_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_version_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(AmberPTParser.VERSION)
            self.state = 159
            self.match(AmberPTParser.VERSION_STAMP)
            self.state = 160
            self.match(AmberPTParser.Equ_op)
            self.state = 161
            self.match(AmberPTParser.Version)
            self.state = 162
            self.match(AmberPTParser.DATE)
            self.state = 163
            self.match(AmberPTParser.Equ_op)
            self.state = 164
            self.match(AmberPTParser.Date_time)
            self.state = 166
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AmberPTParser.Date_time:
                self.state = 165
                self.match(AmberPTParser.Date_time)


            self.state = 168
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_V):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Amber_atom_type_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AMBER_ATOM_TYPE(self):
            return self.getToken(AmberPTParser.AMBER_ATOM_TYPE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_amber_atom_type_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAmber_atom_type_statement" ):
                listener.enterAmber_atom_type_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAmber_atom_type_statement" ):
                listener.exitAmber_atom_type_statement(self)




    def amber_atom_type_statement(self):

        localctx = AmberPTParser.Amber_atom_type_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_amber_atom_type_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(AmberPTParser.AMBER_ATOM_TYPE)
            self.state = 171
            self.format_function()
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 172
                self.match(AmberPTParser.Simple_name)
                self.state = 177
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 178
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Angle_equil_value_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANGLE_EQUIL_VALUE(self):
            return self.getToken(AmberPTParser.ANGLE_EQUIL_VALUE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_angle_equil_value_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAngle_equil_value_statement" ):
                listener.enterAngle_equil_value_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAngle_equil_value_statement" ):
                listener.exitAngle_equil_value_statement(self)




    def angle_equil_value_statement(self):

        localctx = AmberPTParser.Angle_equil_value_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_angle_equil_value_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(AmberPTParser.ANGLE_EQUIL_VALUE)
            self.state = 181
            self.format_function()
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 182
                self.match(AmberPTParser.Real)
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Angle_force_constant_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANGLE_FORCE_CONSTANT(self):
            return self.getToken(AmberPTParser.ANGLE_FORCE_CONSTANT, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_angle_force_constant_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAngle_force_constant_statement" ):
                listener.enterAngle_force_constant_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAngle_force_constant_statement" ):
                listener.exitAngle_force_constant_statement(self)




    def angle_force_constant_statement(self):

        localctx = AmberPTParser.Angle_force_constant_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_angle_force_constant_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(AmberPTParser.ANGLE_FORCE_CONSTANT)
            self.state = 191
            self.format_function()
            self.state = 195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 192
                self.match(AmberPTParser.Real)
                self.state = 197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 198
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Angles_inc_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANGLES_INC_HYDROGEN(self):
            return self.getToken(AmberPTParser.ANGLES_INC_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_angles_inc_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAngles_inc_hydrogen_statement" ):
                listener.enterAngles_inc_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAngles_inc_hydrogen_statement" ):
                listener.exitAngles_inc_hydrogen_statement(self)




    def angles_inc_hydrogen_statement(self):

        localctx = AmberPTParser.Angles_inc_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_angles_inc_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(AmberPTParser.ANGLES_INC_HYDROGEN)
            self.state = 201
            self.format_function()
            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 202
                self.match(AmberPTParser.Integer)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 208
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Angles_without_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANGLES_WITHOUT_HYDROGEN(self):
            return self.getToken(AmberPTParser.ANGLES_WITHOUT_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_angles_without_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAngles_without_hydrogen_statement" ):
                listener.enterAngles_without_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAngles_without_hydrogen_statement" ):
                listener.exitAngles_without_hydrogen_statement(self)




    def angles_without_hydrogen_statement(self):

        localctx = AmberPTParser.Angles_without_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_angles_without_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(AmberPTParser.ANGLES_WITHOUT_HYDROGEN)
            self.state = 211
            self.format_function()
            self.state = 215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 212
                self.match(AmberPTParser.Integer)
                self.state = 217
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 218
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_number_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOMIC_NUMBER(self):
            return self.getToken(AmberPTParser.ATOMIC_NUMBER, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_atomic_number_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_number_statement" ):
                listener.enterAtomic_number_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_number_statement" ):
                listener.exitAtomic_number_statement(self)




    def atomic_number_statement(self):

        localctx = AmberPTParser.Atomic_number_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atomic_number_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.match(AmberPTParser.ATOMIC_NUMBER)
            self.state = 221
            self.format_function()
            self.state = 225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 222
                self.match(AmberPTParser.Integer)
                self.state = 227
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 228
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atom_name_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_NAME(self):
            return self.getToken(AmberPTParser.ATOM_NAME, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_atom_name_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_name_statement" ):
                listener.enterAtom_name_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_name_statement" ):
                listener.exitAtom_name_statement(self)




    def atom_name_statement(self):

        localctx = AmberPTParser.Atom_name_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_atom_name_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(AmberPTParser.ATOM_NAME)
            self.state = 231
            self.format_function()
            self.state = 235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 232
                self.match(AmberPTParser.Simple_name)
                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 238
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atom_type_index_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_TYPE_INDEX(self):
            return self.getToken(AmberPTParser.ATOM_TYPE_INDEX, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_atom_type_index_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_type_index_statement" ):
                listener.enterAtom_type_index_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_type_index_statement" ):
                listener.exitAtom_type_index_statement(self)




    def atom_type_index_statement(self):

        localctx = AmberPTParser.Atom_type_index_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_atom_type_index_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(AmberPTParser.ATOM_TYPE_INDEX)
            self.state = 241
            self.format_function()
            self.state = 245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 242
                self.match(AmberPTParser.Integer)
                self.state = 247
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 248
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atoms_per_molecule_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOMS_PER_MOLECULE(self):
            return self.getToken(AmberPTParser.ATOMS_PER_MOLECULE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_atoms_per_molecule_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtoms_per_molecule_statement" ):
                listener.enterAtoms_per_molecule_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtoms_per_molecule_statement" ):
                listener.exitAtoms_per_molecule_statement(self)




    def atoms_per_molecule_statement(self):

        localctx = AmberPTParser.Atoms_per_molecule_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_atoms_per_molecule_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(AmberPTParser.ATOMS_PER_MOLECULE)
            self.state = 251
            self.format_function()
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 252
                self.match(AmberPTParser.Integer)
                self.state = 257
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 258
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bond_equil_value_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOND_EQUIL_VALUE(self):
            return self.getToken(AmberPTParser.BOND_EQUIL_VALUE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_bond_equil_value_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBond_equil_value_statement" ):
                listener.enterBond_equil_value_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBond_equil_value_statement" ):
                listener.exitBond_equil_value_statement(self)




    def bond_equil_value_statement(self):

        localctx = AmberPTParser.Bond_equil_value_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bond_equil_value_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(AmberPTParser.BOND_EQUIL_VALUE)
            self.state = 261
            self.format_function()
            self.state = 265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 262
                self.match(AmberPTParser.Real)
                self.state = 267
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 268
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bond_force_constant_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOND_FORCE_CONSTANT(self):
            return self.getToken(AmberPTParser.BOND_FORCE_CONSTANT, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_bond_force_constant_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBond_force_constant_statement" ):
                listener.enterBond_force_constant_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBond_force_constant_statement" ):
                listener.exitBond_force_constant_statement(self)




    def bond_force_constant_statement(self):

        localctx = AmberPTParser.Bond_force_constant_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_bond_force_constant_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(AmberPTParser.BOND_FORCE_CONSTANT)
            self.state = 271
            self.format_function()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 272
                self.match(AmberPTParser.Real)
                self.state = 277
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 278
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bonds_inc_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BONDS_INC_HYDROGEN(self):
            return self.getToken(AmberPTParser.BONDS_INC_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_bonds_inc_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBonds_inc_hydrogen_statement" ):
                listener.enterBonds_inc_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBonds_inc_hydrogen_statement" ):
                listener.exitBonds_inc_hydrogen_statement(self)




    def bonds_inc_hydrogen_statement(self):

        localctx = AmberPTParser.Bonds_inc_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_bonds_inc_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(AmberPTParser.BONDS_INC_HYDROGEN)
            self.state = 281
            self.format_function()
            self.state = 285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 282
                self.match(AmberPTParser.Integer)
                self.state = 287
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 288
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bonds_without_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BONDS_WITHOUT_HYDROGEN(self):
            return self.getToken(AmberPTParser.BONDS_WITHOUT_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_bonds_without_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBonds_without_hydrogen_statement" ):
                listener.enterBonds_without_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBonds_without_hydrogen_statement" ):
                listener.exitBonds_without_hydrogen_statement(self)




    def bonds_without_hydrogen_statement(self):

        localctx = AmberPTParser.Bonds_without_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_bonds_without_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(AmberPTParser.BONDS_WITHOUT_HYDROGEN)
            self.state = 291
            self.format_function()
            self.state = 295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 292
                self.match(AmberPTParser.Integer)
                self.state = 297
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 298
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Box_dimensions_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOX_DIMENSIONS(self):
            return self.getToken(AmberPTParser.BOX_DIMENSIONS, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_box_dimensions_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBox_dimensions_statement" ):
                listener.enterBox_dimensions_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBox_dimensions_statement" ):
                listener.exitBox_dimensions_statement(self)




    def box_dimensions_statement(self):

        localctx = AmberPTParser.Box_dimensions_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_box_dimensions_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(AmberPTParser.BOX_DIMENSIONS)
            self.state = 301
            self.format_function()
            self.state = 305
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 302
                self.match(AmberPTParser.Real)
                self.state = 307
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 308
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cap_info_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAP_INFO(self):
            return self.getToken(AmberPTParser.CAP_INFO, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_cap_info_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCap_info_statement" ):
                listener.enterCap_info_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCap_info_statement" ):
                listener.exitCap_info_statement(self)




    def cap_info_statement(self):

        localctx = AmberPTParser.Cap_info_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_cap_info_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(AmberPTParser.CAP_INFO)
            self.state = 311
            self.format_function()
            self.state = 315
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 312
                self.match(AmberPTParser.Integer)
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 318
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cap_info2_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAP_INFO2(self):
            return self.getToken(AmberPTParser.CAP_INFO2, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_cap_info2_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCap_info2_statement" ):
                listener.enterCap_info2_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCap_info2_statement" ):
                listener.exitCap_info2_statement(self)




    def cap_info2_statement(self):

        localctx = AmberPTParser.Cap_info2_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_cap_info2_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(AmberPTParser.CAP_INFO2)
            self.state = 321
            self.format_function()
            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 322
                self.match(AmberPTParser.Real)
                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 328
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Charge_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHARGE(self):
            return self.getToken(AmberPTParser.CHARGE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_charge_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharge_statement" ):
                listener.enterCharge_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharge_statement" ):
                listener.exitCharge_statement(self)




    def charge_statement(self):

        localctx = AmberPTParser.Charge_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_charge_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.match(AmberPTParser.CHARGE)
            self.state = 331
            self.format_function()
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 332
                self.match(AmberPTParser.Real)
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 338
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dihedral_force_constant_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIHEDRAL_FORCE_CONSTANT(self):
            return self.getToken(AmberPTParser.DIHEDRAL_FORCE_CONSTANT, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_dihedral_force_constant_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDihedral_force_constant_statement" ):
                listener.enterDihedral_force_constant_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDihedral_force_constant_statement" ):
                listener.exitDihedral_force_constant_statement(self)




    def dihedral_force_constant_statement(self):

        localctx = AmberPTParser.Dihedral_force_constant_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_dihedral_force_constant_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(AmberPTParser.DIHEDRAL_FORCE_CONSTANT)
            self.state = 341
            self.format_function()
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 342
                self.match(AmberPTParser.Real)
                self.state = 347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 348
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dihedral_periodicity_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIHEDRAL_PERIODICITY(self):
            return self.getToken(AmberPTParser.DIHEDRAL_PERIODICITY, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_dihedral_periodicity_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDihedral_periodicity_statement" ):
                listener.enterDihedral_periodicity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDihedral_periodicity_statement" ):
                listener.exitDihedral_periodicity_statement(self)




    def dihedral_periodicity_statement(self):

        localctx = AmberPTParser.Dihedral_periodicity_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_dihedral_periodicity_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(AmberPTParser.DIHEDRAL_PERIODICITY)
            self.state = 351
            self.format_function()
            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 352
                self.match(AmberPTParser.Real)
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 358
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dihedral_phase_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIHEDRAL_PHASE(self):
            return self.getToken(AmberPTParser.DIHEDRAL_PHASE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_dihedral_phase_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDihedral_phase_statement" ):
                listener.enterDihedral_phase_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDihedral_phase_statement" ):
                listener.exitDihedral_phase_statement(self)




    def dihedral_phase_statement(self):

        localctx = AmberPTParser.Dihedral_phase_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_dihedral_phase_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(AmberPTParser.DIHEDRAL_PHASE)
            self.state = 361
            self.format_function()
            self.state = 365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 362
                self.match(AmberPTParser.Real)
                self.state = 367
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 368
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dihedrals_inc_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIHEDRALS_INC_HYDROGEN(self):
            return self.getToken(AmberPTParser.DIHEDRALS_INC_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_dihedrals_inc_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDihedrals_inc_hydrogen_statement" ):
                listener.enterDihedrals_inc_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDihedrals_inc_hydrogen_statement" ):
                listener.exitDihedrals_inc_hydrogen_statement(self)




    def dihedrals_inc_hydrogen_statement(self):

        localctx = AmberPTParser.Dihedrals_inc_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_dihedrals_inc_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 370
            self.match(AmberPTParser.DIHEDRALS_INC_HYDROGEN)
            self.state = 371
            self.format_function()
            self.state = 375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 372
                self.match(AmberPTParser.Integer)
                self.state = 377
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 378
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dihedrals_without_hydrogen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIHEDRALS_WITHOUT_HYDROGEN(self):
            return self.getToken(AmberPTParser.DIHEDRALS_WITHOUT_HYDROGEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_dihedrals_without_hydrogen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDihedrals_without_hydrogen_statement" ):
                listener.enterDihedrals_without_hydrogen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDihedrals_without_hydrogen_statement" ):
                listener.exitDihedrals_without_hydrogen_statement(self)




    def dihedrals_without_hydrogen_statement(self):

        localctx = AmberPTParser.Dihedrals_without_hydrogen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_dihedrals_without_hydrogen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 380
            self.match(AmberPTParser.DIHEDRALS_WITHOUT_HYDROGEN)
            self.state = 381
            self.format_function()
            self.state = 385
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 382
                self.match(AmberPTParser.Integer)
                self.state = 387
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 388
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Excluded_atoms_list_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLUDED_ATOMS_LIST(self):
            return self.getToken(AmberPTParser.EXCLUDED_ATOMS_LIST, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_excluded_atoms_list_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExcluded_atoms_list_statement" ):
                listener.enterExcluded_atoms_list_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExcluded_atoms_list_statement" ):
                listener.exitExcluded_atoms_list_statement(self)




    def excluded_atoms_list_statement(self):

        localctx = AmberPTParser.Excluded_atoms_list_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_excluded_atoms_list_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(AmberPTParser.EXCLUDED_ATOMS_LIST)
            self.state = 391
            self.format_function()
            self.state = 395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 392
                self.match(AmberPTParser.Integer)
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 398
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hbcut_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HBCUT(self):
            return self.getToken(AmberPTParser.HBCUT, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_hbcut_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHbcut_statement" ):
                listener.enterHbcut_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHbcut_statement" ):
                listener.exitHbcut_statement(self)




    def hbcut_statement(self):

        localctx = AmberPTParser.Hbcut_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_hbcut_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self.match(AmberPTParser.HBCUT)
            self.state = 401
            self.format_function()
            self.state = 405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 402
                self.match(AmberPTParser.Real)
                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 408
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hbond_acoef_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HBOND_ACOEF(self):
            return self.getToken(AmberPTParser.HBOND_ACOEF, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_hbond_acoef_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHbond_acoef_statement" ):
                listener.enterHbond_acoef_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHbond_acoef_statement" ):
                listener.exitHbond_acoef_statement(self)




    def hbond_acoef_statement(self):

        localctx = AmberPTParser.Hbond_acoef_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_hbond_acoef_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(AmberPTParser.HBOND_ACOEF)
            self.state = 411
            self.format_function()
            self.state = 415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 412
                self.match(AmberPTParser.Real)
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 418
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hbond_bcoef_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HBOND_BCOEF(self):
            return self.getToken(AmberPTParser.HBOND_BCOEF, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_hbond_bcoef_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHbond_bcoef_statement" ):
                listener.enterHbond_bcoef_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHbond_bcoef_statement" ):
                listener.exitHbond_bcoef_statement(self)




    def hbond_bcoef_statement(self):

        localctx = AmberPTParser.Hbond_bcoef_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_hbond_bcoef_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            self.match(AmberPTParser.HBOND_BCOEF)
            self.state = 421
            self.format_function()
            self.state = 425
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 422
                self.match(AmberPTParser.Real)
                self.state = 427
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 428
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipol_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IPOL(self):
            return self.getToken(AmberPTParser.IPOL, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_ipol_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpol_statement" ):
                listener.enterIpol_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpol_statement" ):
                listener.exitIpol_statement(self)




    def ipol_statement(self):

        localctx = AmberPTParser.Ipol_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ipol_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(AmberPTParser.IPOL)
            self.state = 431
            self.format_function()
            self.state = 435
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 432
                self.match(AmberPTParser.Integer)
                self.state = 437
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 438
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Irotat_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IROTAT(self):
            return self.getToken(AmberPTParser.IROTAT, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_irotat_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIrotat_statement" ):
                listener.enterIrotat_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIrotat_statement" ):
                listener.exitIrotat_statement(self)




    def irotat_statement(self):

        localctx = AmberPTParser.Irotat_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_irotat_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self.match(AmberPTParser.IROTAT)
            self.state = 441
            self.format_function()
            self.state = 445
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 442
                self.match(AmberPTParser.Integer)
                self.state = 447
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 448
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_array_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOIN_ARRAY(self):
            return self.getToken(AmberPTParser.JOIN_ARRAY, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_join_array_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin_array_statement" ):
                listener.enterJoin_array_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin_array_statement" ):
                listener.exitJoin_array_statement(self)




    def join_array_statement(self):

        localctx = AmberPTParser.Join_array_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_join_array_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self.match(AmberPTParser.JOIN_ARRAY)
            self.state = 451
            self.format_function()
            self.state = 455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 452
                self.match(AmberPTParser.Integer)
                self.state = 457
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 458
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lennard_jones_acoef_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LENNARD_JONES_ACOEF(self):
            return self.getToken(AmberPTParser.LENNARD_JONES_ACOEF, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_lennard_jones_acoef_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLennard_jones_acoef_statement" ):
                listener.enterLennard_jones_acoef_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLennard_jones_acoef_statement" ):
                listener.exitLennard_jones_acoef_statement(self)




    def lennard_jones_acoef_statement(self):

        localctx = AmberPTParser.Lennard_jones_acoef_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_lennard_jones_acoef_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 460
            self.match(AmberPTParser.LENNARD_JONES_ACOEF)
            self.state = 461
            self.format_function()
            self.state = 465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 462
                self.match(AmberPTParser.Real)
                self.state = 467
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 468
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lennard_jones_bcoef_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LENNARD_JONES_BCOEF(self):
            return self.getToken(AmberPTParser.LENNARD_JONES_BCOEF, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_lennard_jones_bcoef_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLennard_jones_bcoef_statement" ):
                listener.enterLennard_jones_bcoef_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLennard_jones_bcoef_statement" ):
                listener.exitLennard_jones_bcoef_statement(self)




    def lennard_jones_bcoef_statement(self):

        localctx = AmberPTParser.Lennard_jones_bcoef_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_lennard_jones_bcoef_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 470
            self.match(AmberPTParser.LENNARD_JONES_BCOEF)
            self.state = 471
            self.format_function()
            self.state = 475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 472
                self.match(AmberPTParser.Real)
                self.state = 477
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 478
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mass_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MASS(self):
            return self.getToken(AmberPTParser.MASS, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_mass_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMass_statement" ):
                listener.enterMass_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMass_statement" ):
                listener.exitMass_statement(self)




    def mass_statement(self):

        localctx = AmberPTParser.Mass_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_mass_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.match(AmberPTParser.MASS)
            self.state = 481
            self.format_function()
            self.state = 485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 482
                self.match(AmberPTParser.Real)
                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 488
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nonbonded_parm_index_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NONBONDED_PARM_INDEX(self):
            return self.getToken(AmberPTParser.NONBONDED_PARM_INDEX, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_nonbonded_parm_index_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNonbonded_parm_index_statement" ):
                listener.enterNonbonded_parm_index_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNonbonded_parm_index_statement" ):
                listener.exitNonbonded_parm_index_statement(self)




    def nonbonded_parm_index_statement(self):

        localctx = AmberPTParser.Nonbonded_parm_index_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_nonbonded_parm_index_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.match(AmberPTParser.NONBONDED_PARM_INDEX)
            self.state = 491
            self.format_function()
            self.state = 495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 492
                self.match(AmberPTParser.Integer)
                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 498
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Number_excluded_atoms_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER_EXCLUDED_ATOMS(self):
            return self.getToken(AmberPTParser.NUMBER_EXCLUDED_ATOMS, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_number_excluded_atoms_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber_excluded_atoms_statement" ):
                listener.enterNumber_excluded_atoms_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber_excluded_atoms_statement" ):
                listener.exitNumber_excluded_atoms_statement(self)




    def number_excluded_atoms_statement(self):

        localctx = AmberPTParser.Number_excluded_atoms_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_number_excluded_atoms_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 500
            self.match(AmberPTParser.NUMBER_EXCLUDED_ATOMS)
            self.state = 501
            self.format_function()
            self.state = 505
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 502
                self.match(AmberPTParser.Integer)
                self.state = 507
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 508
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pointers_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POINTERS(self):
            return self.getToken(AmberPTParser.POINTERS, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_pointers_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPointers_statement" ):
                listener.enterPointers_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPointers_statement" ):
                listener.exitPointers_statement(self)




    def pointers_statement(self):

        localctx = AmberPTParser.Pointers_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_pointers_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            self.match(AmberPTParser.POINTERS)
            self.state = 511
            self.format_function()
            self.state = 515
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 512
                self.match(AmberPTParser.Integer)
                self.state = 517
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 518
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Polarizability_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLARIZABILITY(self):
            return self.getToken(AmberPTParser.POLARIZABILITY, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_polarizability_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolarizability_statement" ):
                listener.enterPolarizability_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolarizability_statement" ):
                listener.exitPolarizability_statement(self)




    def polarizability_statement(self):

        localctx = AmberPTParser.Polarizability_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_polarizability_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.match(AmberPTParser.POLARIZABILITY)
            self.state = 521
            self.format_function()
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 522
                self.match(AmberPTParser.Real)
                self.state = 527
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 528
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Radii_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RADII(self):
            return self.getToken(AmberPTParser.RADII, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_radii_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRadii_statement" ):
                listener.enterRadii_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRadii_statement" ):
                listener.exitRadii_statement(self)




    def radii_statement(self):

        localctx = AmberPTParser.Radii_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_radii_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 530
            self.match(AmberPTParser.RADII)
            self.state = 531
            self.format_function()
            self.state = 535
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 532
                self.match(AmberPTParser.Real)
                self.state = 537
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 538
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Radius_set_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RADIUS_SET(self):
            return self.getToken(AmberPTParser.RADIUS_SET, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_radius_set_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRadius_set_statement" ):
                listener.enterRadius_set_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRadius_set_statement" ):
                listener.exitRadius_set_statement(self)




    def radius_set_statement(self):

        localctx = AmberPTParser.Radius_set_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_radius_set_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(AmberPTParser.RADIUS_SET)
            self.state = 541
            self.format_function()
            self.state = 545
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 542
                self.match(AmberPTParser.Simple_name)
                self.state = 547
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 548
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Residue_label_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESIDUE_LABEL(self):
            return self.getToken(AmberPTParser.RESIDUE_LABEL, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_residue_label_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResidue_label_statement" ):
                listener.enterResidue_label_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResidue_label_statement" ):
                listener.exitResidue_label_statement(self)




    def residue_label_statement(self):

        localctx = AmberPTParser.Residue_label_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_residue_label_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 550
            self.match(AmberPTParser.RESIDUE_LABEL)
            self.state = 551
            self.format_function()
            self.state = 555
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 552
                self.match(AmberPTParser.Simple_name)
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 558
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Residue_pointer_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESIDUE_POINTER(self):
            return self.getToken(AmberPTParser.RESIDUE_POINTER, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_residue_pointer_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResidue_pointer_statement" ):
                listener.enterResidue_pointer_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResidue_pointer_statement" ):
                listener.exitResidue_pointer_statement(self)




    def residue_pointer_statement(self):

        localctx = AmberPTParser.Residue_pointer_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_residue_pointer_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 560
            self.match(AmberPTParser.RESIDUE_POINTER)
            self.state = 561
            self.format_function()
            self.state = 563 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 562
                self.match(AmberPTParser.Integer)
                self.state = 565 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==AmberPTParser.Integer):
                    break

            self.state = 567
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Scee_scale_factor_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCEE_SCALE_FACTOR(self):
            return self.getToken(AmberPTParser.SCEE_SCALE_FACTOR, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_scee_scale_factor_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScee_scale_factor_statement" ):
                listener.enterScee_scale_factor_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScee_scale_factor_statement" ):
                listener.exitScee_scale_factor_statement(self)




    def scee_scale_factor_statement(self):

        localctx = AmberPTParser.Scee_scale_factor_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_scee_scale_factor_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 569
            self.match(AmberPTParser.SCEE_SCALE_FACTOR)
            self.state = 570
            self.format_function()
            self.state = 574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 571
                self.match(AmberPTParser.Real)
                self.state = 576
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 577
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Scnb_scale_factor_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCNB_SCALE_FACTOR(self):
            return self.getToken(AmberPTParser.SCNB_SCALE_FACTOR, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_scnb_scale_factor_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScnb_scale_factor_statement" ):
                listener.enterScnb_scale_factor_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScnb_scale_factor_statement" ):
                listener.exitScnb_scale_factor_statement(self)




    def scnb_scale_factor_statement(self):

        localctx = AmberPTParser.Scnb_scale_factor_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_scnb_scale_factor_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(AmberPTParser.SCNB_SCALE_FACTOR)
            self.state = 580
            self.format_function()
            self.state = 584
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 581
                self.match(AmberPTParser.Real)
                self.state = 586
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 587
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Screen_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCREEN(self):
            return self.getToken(AmberPTParser.SCREEN, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_screen_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScreen_statement" ):
                listener.enterScreen_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScreen_statement" ):
                listener.exitScreen_statement(self)




    def screen_statement(self):

        localctx = AmberPTParser.Screen_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_screen_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self.match(AmberPTParser.SCREEN)
            self.state = 590
            self.format_function()
            self.state = 594
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 591
                self.match(AmberPTParser.Real)
                self.state = 596
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 597
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Solty_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOLTY(self):
            return self.getToken(AmberPTParser.SOLTY, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_E(self):
            return self.getToken(AmberPTParser.FLAG_E, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Real(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Real)
            else:
                return self.getToken(AmberPTParser.Real, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_solty_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSolty_statement" ):
                listener.enterSolty_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSolty_statement" ):
                listener.exitSolty_statement(self)




    def solty_statement(self):

        localctx = AmberPTParser.Solty_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_solty_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 599
            self.match(AmberPTParser.SOLTY)
            self.state = 600
            self.format_function()
            self.state = 604
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Real:
                self.state = 601
                self.match(AmberPTParser.Real)
                self.state = 606
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 607
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_E):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Solvent_pointers_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOLVENT_POINTERS(self):
            return self.getToken(AmberPTParser.SOLVENT_POINTERS, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_I(self):
            return self.getToken(AmberPTParser.FLAG_I, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Integer)
            else:
                return self.getToken(AmberPTParser.Integer, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_solvent_pointers_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSolvent_pointers_statement" ):
                listener.enterSolvent_pointers_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSolvent_pointers_statement" ):
                listener.exitSolvent_pointers_statement(self)




    def solvent_pointers_statement(self):

        localctx = AmberPTParser.Solvent_pointers_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_solvent_pointers_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 609
            self.match(AmberPTParser.SOLVENT_POINTERS)
            self.state = 610
            self.format_function()
            self.state = 614
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Integer:
                self.state = 611
                self.match(AmberPTParser.Integer)
                self.state = 616
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 617
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_I):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Title_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TITLE(self):
            return self.getToken(AmberPTParser.TITLE, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_title_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTitle_statement" ):
                listener.enterTitle_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTitle_statement" ):
                listener.exitTitle_statement(self)




    def title_statement(self):

        localctx = AmberPTParser.Title_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_title_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self.match(AmberPTParser.TITLE)
            self.state = 620
            self.format_function()
            self.state = 624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 621
                self.match(AmberPTParser.Simple_name)
                self.state = 626
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 627
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tree_chain_classification_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TREE_CHAIN_CLASSIFICATION(self):
            return self.getToken(AmberPTParser.TREE_CHAIN_CLASSIFICATION, 0)

        def format_function(self):
            return self.getTypedRuleContext(AmberPTParser.Format_functionContext,0)


        def FLAG_A(self):
            return self.getToken(AmberPTParser.FLAG_A, 0)

        def EOF(self):
            return self.getToken(AmberPTParser.EOF, 0)

        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(AmberPTParser.Simple_name)
            else:
                return self.getToken(AmberPTParser.Simple_name, i)

        def getRuleIndex(self):
            return AmberPTParser.RULE_tree_chain_classification_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTree_chain_classification_statement" ):
                listener.enterTree_chain_classification_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTree_chain_classification_statement" ):
                listener.exitTree_chain_classification_statement(self)




    def tree_chain_classification_statement(self):

        localctx = AmberPTParser.Tree_chain_classification_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tree_chain_classification_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 629
            self.match(AmberPTParser.TREE_CHAIN_CLASSIFICATION)
            self.state = 630
            self.format_function()
            self.state = 634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AmberPTParser.Simple_name:
                self.state = 631
                self.match(AmberPTParser.Simple_name)
                self.state = 636
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 637
            _la = self._input.LA(1)
            if not(_la==AmberPTParser.EOF or _la==AmberPTParser.FLAG_A):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Format_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT(self):
            return self.getToken(AmberPTParser.FORMAT, 0)

        def Fortran_format_A(self):
            return self.getToken(AmberPTParser.Fortran_format_A, 0)

        def Fortran_format_I(self):
            return self.getToken(AmberPTParser.Fortran_format_I, 0)

        def Fortran_format_E(self):
            return self.getToken(AmberPTParser.Fortran_format_E, 0)

        def getRuleIndex(self):
            return AmberPTParser.RULE_format_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormat_function" ):
                listener.enterFormat_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormat_function" ):
                listener.exitFormat_function(self)




    def format_function(self):

        localctx = AmberPTParser.Format_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_format_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self.match(AmberPTParser.FORMAT)
            self.state = 640
            _la = self._input.LA(1)
            if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (AmberPTParser.Fortran_format_A - 63)) | (1 << (AmberPTParser.Fortran_format_I - 63)) | (1 << (AmberPTParser.Fortran_format_E - 63)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





