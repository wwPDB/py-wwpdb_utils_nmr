##
# File: CyanaMRParserListener.py
# Date: 27-Jan-2022
#
# Updates:
# Generated from CyanaMRParser.g4 by ANTLR 4.9
""" ParserLister class for CYANA MR files.
    @author: Masashi Yokochi
"""
import sys

from antlr4 import ParseTreeListener

try:
    from wwpdb.utils.nmr.mr.CyanaMRParser import CyanaMRParser
    from wwpdb.utils.nmr.mr.ParserListenerUtil import (checkCoordinates,
                                                       DIST_RESTRAINT_RANGE,
                                                       DIST_RESTRAINT_ERROR,
                                                       ANGLE_RESTRAINT_RANGE,
                                                       ANGLE_RESTRAINT_ERROR,
                                                       KNOWN_ANGLE_NAMES,
                                                       KNOWN_ANGLE_ATOM_NAMES,
                                                       KNOWN_ANGLE_SEQ_OFFSET)

    from wwpdb.utils.nmr.ChemCompUtil import ChemCompUtil
    from wwpdb.utils.nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from wwpdb.utils.nmr.NEFTranslator.NEFTranslator import NEFTranslator
except ImportError:
    from nmr.mr.CyanaMRParser import CyanaMRParser
    from nmr.mr.ParserListenerUtil import (checkCoordinates,
                                           DIST_RESTRAINT_RANGE,
                                           DIST_RESTRAINT_ERROR,
                                           ANGLE_RESTRAINT_RANGE,
                                           ANGLE_RESTRAINT_ERROR,
                                           KNOWN_ANGLE_NAMES,
                                           KNOWN_ANGLE_ATOM_NAMES,
                                           KNOWN_ANGLE_SEQ_OFFSET)

    from nmr.ChemCompUtil import ChemCompUtil
    from nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from nmr.NEFTranslator.NEFTranslator import NEFTranslator


DIST_RANGE_MIN = DIST_RESTRAINT_RANGE['min_inclusive']
DIST_RANGE_MAX = DIST_RESTRAINT_RANGE['max_inclusive']

DIST_ERROR_MIN = DIST_RESTRAINT_ERROR['min_exclusive']
DIST_ERROR_MAX = DIST_RESTRAINT_ERROR['max_exclusive']


ANGLE_RANGE_MIN = ANGLE_RESTRAINT_RANGE['min_inclusive']
ANGLE_RANGE_MAX = ANGLE_RESTRAINT_RANGE['max_inclusive']

ANGLE_ERROR_MIN = ANGLE_RESTRAINT_ERROR['min_exclusive']
ANGLE_ERROR_MAX = ANGLE_RESTRAINT_ERROR['max_exclusive']


# This class defines a complete listener for a parse tree produced by CyanaMRParser.
class CyanaMRParserListener(ParseTreeListener):

    __verbose = None
    __lfh = None

    distRestraints = 0      # CYANA: Distance restraint file
    dihedRestraints = 0     # CYANA: Torsion angle restraint file
    rdcRestraints = 0       # CYANA: Residual dipolar coupling restraint file
    pcsRestraints = 0       # CYANA: Pseudocontact shift restraint file

    # CCD accessing utility
    __ccU = None

    # BMRB chemical shift statistics
    __csStat = None

    # NEFTranslator
    __nefT = None

    __upl_or_lol = None  # must be one of (None, 'upl_only', 'upl_w_lol', 'lol_only', 'lol_w_upl')

    # CIF reader
    __cR = None
    __hasCoord = False

    # data item name for model ID in 'atom_site' category
    __modelNumName = None

    # data item names for auth_asym_id, auth_seq_id, auth_atom_id in 'atom_site' category
    __authAsymId = None
    __authSeqId = None
    __authAtomId = None
    __altAuthAtomId = None

    # polymer sequences in the coordinate file generated by NmrDpUtility.__extractCoordPolymerSequence()
    __hasPolySeq = False
    __polySeq = None
    __altPolySeq = None
    __coordAtomSite = None
    __coordUnobsRes = None
    __labelToAuthSeq = None
    __preferAuthSeq = True

    # current restraint subtype
    __cur_subtype = None

    # collection of atom selection
    atomSelectionSet = None

    warningMessage = ''

    def __init__(self, verbose=True, log=sys.stdout, cR=None, polySeq=None,
                 coordAtomSite=None, coordUnobsRes=None, labelToAuthSeq=None,
                 ccU=None, csStat=None, nefT=None, upl_or_lol=None):
        self.__verbose = verbose
        self.__lfh = log
        self.__cR = cR
        self.__hasCoord = cR is not None

        if self.__hasCoord:
            ret = checkCoordinates(verbose, log, cR, polySeq,
                                   coordAtomSite, coordUnobsRes, labelToAuthSeq)
            self.__modelNumName = ret['model_num_name']
            self.__authAsymId = ret['auth_asym_id']
            self.__authSeqId = ret['auth_seq_id']
            self.__authAtomId = ret['auth_atom_id']
            self.__altAuthAtomId = ret['alt_auth_atom_id']
            self.__polySeq = ret['polymer_sequence']
            self.__altPolySeq = ret['alt_polymer_sequence']
            self.__coordAtomSite = ret['coord_atom_site']
            self.__coordUnobsRes = ret['coord_unobs_res']
            self.__labelToAuthSeq = ret['label_to_auth_seq']

        self.__hasPolySeq = self.__polySeq is not None and len(self.__polySeq) > 0

        # CCD accessing utility
        self.__ccU = ChemCompUtil(verbose, log) if ccU is None else ccU

        # BMRB chemical shift statistics
        self.__csStat = BMRBChemShiftStat(verbose, log, self.__ccU) if csStat is None else csStat

        # NEFTranslator
        self.__nefT = NEFTranslator(verbose, log, self.__ccU, self.__csStat) if nefT is None else nefT

        self.__upl_or_lol = upl_or_lol

        if upl_or_lol not in (None, 'upl_only', 'upl_w_lol', 'lol_only', 'lol_w_upl'):
            msg = f"The argument 'upl_or_lol' must be one of {(None, 'upl_only', 'upl_w_lol', 'lol_only', 'lol_w_upl')}"
            self.__lfh.write(f"'+CyanaMRParserListener.__init__() ++ ValueError  -  {msg}\n")
            raise ValueError(f"'+CyanaMRParserListener.__init__() ++ ValueError  -  {msg}")

    # Enter a parse tree produced by CyanaMRParser#cyana_mr.
    def enterCyana_mr(self, ctx: CyanaMRParser.Cyana_mrContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by CyanaMRParser#cyana_mr.
    def exitCyana_mr(self, ctx: CyanaMRParser.Cyana_mrContext):  # pylint: disable=unused-argument
        if len(self.warningMessage) == 0:
            self.warningMessage = None
        else:
            self.warningMessage = self.warningMessage[0:-1]
            self.warningMessage = '\n'.join(set(self.warningMessage.split('\n')))

    # Enter a parse tree produced by CyanaMRParser#distance_restraints.
    def enterDistance_restraints(self, ctx: CyanaMRParser.Distance_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dist'

    # Exit a parse tree produced by CyanaMRParser#distance_restraints.
    def exitDistance_restraints(self, ctx: CyanaMRParser.Distance_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#distance_restraint.
    def enterDistance_restraint(self, ctx: CyanaMRParser.Distance_restraintContext):  # pylint: disable=unused-argument
        self.distRestraints += 1

        self.atomSelectionSet = []

    # Exit a parse tree produced by CyanaMRParser#distance_restraint.
    def exitDistance_restraint(self, ctx: CyanaMRParser.Distance_restraintContext):
        if not self.__hasPolySeq:
            return

        seqId1 = int(str(ctx.Integer(0)))
        compId1 = str(ctx.Simple_name(0)).upper()
        atomId1 = str(ctx.Simple_name(1)).upper()
        seqId2 = int(str(ctx.Integer(1)))
        compId2 = str(ctx.Simple_name(2)).upper()
        atomId2 = str(ctx.Simple_name(3)).upper()

        if self.__upl_or_lol is None:
            msg = f"The 'upl_or_lol' argument must be chosen from {('upl_only', 'upl_w_lol', 'lol_only', 'lol_w_upl')}"
            self.__lfh.write(f"'+CyanaMRParserListener.exitDistance_restraint() ++ ValueError  -  {msg}\n")
            raise ValueError(f"'+CyanaMRParserListener.exitDistance_restraint() ++ ValueError  -  {msg}")

        target_value = None
        lower_limit = None
        upper_limit = None

        if self.__upl_or_lol == 'upl_only':
            upper_limit = float(str(ctx.Float()))
            lower_limit = 1.8  # default value of PDBStat
            target_value = (upper_limit + lower_limit) / 2.0  # default procedure of PDBStat

        elif self.__upl_or_lol == 'upl_w_lol':
            upper_limit = float(str(ctx.Float()))

        elif self.__upl_or_lol == 'lol_only':
            lower_limit = float(str(ctx.Float()))
            upper_limit = 5.5  # default value of PDBStat
            target_value = (upper_limit + lower_limit) / 2.0  # default procedure of PDBStat

        else:  # 'lol_w_upl'
            lower_limit = float(str(ctx.Float()))

        validRange = True
        dstFunc = {'weight': 1.0}

        if target_value is not None:
            if DIST_ERROR_MIN < target_value < DIST_ERROR_MAX:
                dstFunc['target_value'] = f"{target_value:.3f}"

        if lower_limit is not None:
            if DIST_ERROR_MIN < lower_limit < DIST_ERROR_MAX:
                dstFunc['lower_limit'] = f"{lower_limit:.3f}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The lower limit value='{lower_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if upper_limit is not None:
            if DIST_ERROR_MIN < upper_limit < DIST_ERROR_MAX:
                dstFunc['upper_limit'] = f"{upper_limit:.3f}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The upper limit value='{upper_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if not validRange:
            return

        if target_value is not None:
            if DIST_RANGE_MIN <= target_value <= DIST_RANGE_MAX:
                pass

        if lower_limit is not None:
            if DIST_RANGE_MIN <= lower_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The lower limit value='{lower_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        if upper_limit is not None:
            if DIST_RANGE_MIN <= upper_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The upper limit value='{upper_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        chainAssign1 = []
        chainAssign2 = []

        for ps in self.__polySeq:
            chainId = ps['chain_id']
            if seqId1 in ps['seq_id']:
                cifCompId = ps['comp_id'][ps['seq_id'].index(seqId1)]
                if cifCompId == compId1:
                    chainAssign1.append((chainId, seqId1, cifCompId))
                elif len(self.__nefT.get_valid_star_atom(cifCompId, atomId1)[0]) > 0:
                    chainAssign1.append((chainId, seqId1, cifCompId))
            if seqId2 in ps['seq_id']:
                cifCompId = ps['comp_id'][ps['seq_id'].index(seqId2)]
                if cifCompId == compId2:
                    chainAssign2.append((chainId, seqId2, cifCompId))
                elif len(self.__nefT.get_valid_star_atom(cifCompId, atomId2)[0]) > 0:
                    chainAssign1.append((chainId, seqId2, cifCompId))

        if len(chainAssign1) == 0 and self.__altPolySeq is not None:
            for ps in self.__altPolySeq:
                chainId = ps['chain_id']
                if seqId1 in ps['auth_seq_id']:
                    cifCompId = ps['comp_id'][ps['auth_seq_id'].index(seqId1)]
                    cifSeqId = ps['seq_id'][ps['auth_seq_id'].index(seqId1)]
                    chainAssign1.append(chainId, cifSeqId, cifCompId)

        if len(chainAssign2) == 0 and self.__altPolySeq is not None:
            for ps in self.__altPolySeq:
                chainId = ps['chain_id']
                if seqId2 in ps['auth_seq_id']:
                    cifCompId = ps['comp_id'][ps['auth_seq_id'].index(seqId2)]
                    cifSeqId = ps['seq_id'][ps['auth_seq_id'].index(seqId2)]
                    chainAssign2.append(chainId, cifSeqId, cifCompId)

        if len(chainAssign1) == 0:
            self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                f"{seqId1}:{compId1}:{atomId1} is not present in the coordinates.\n"

        if len(chainAssign2) == 0:
            self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                f"{seqId2}:{compId2}:{atomId2} is not present in the coordinates.\n"

        if len(chainAssign1) == 0 or len(chainAssign2) == 0:
            return

        atomSelection = []

        for chainId, cifSeqId, cifCompId in chainAssign1:
            seqKey, coordAtomSite = self.getCoordAtomSiteOf(chainId, cifSeqId, self.__hasCoord)

            _atomId1 = self.__nefT.get_valid_star_atom(cifCompId, atomId1)[0]
            if len(_atomId1) == 0:
                self.warningMessage += f"[Invalid atom nomenclature] {self.__getCurrentRestraint()}"\
                    f"{seqId1}:{compId1}:{atomId1} is invalid atom nomenclature.\n"
                continue

            for cifAtomId in _atomId1:
                atomSelection.append({'chain_id': chainId, 'seq_id': cifSeqId, 'comp_id': cifCompId, 'atom_id': cifAtomId})

                self.testCoordAtomIdConsistency(chainId, cifSeqId, cifCompId, cifAtomId, seqKey, coordAtomSite)

        if len(atomSelection) > 0:
            self.atomSelectionSet.append(atomSelection)

        atomSelection = []

        for chainId, cifSeqId, cifCompId in chainAssign2:
            seqKey, coordAtomSite = self.getCoordAtomSiteOf(chainId, cifSeqId, self.__hasCoord)

            _atomId2 = self.__nefT.get_valid_star_atom(cifCompId, atomId2)[0]
            if len(_atomId2) == 0:
                self.warningMessage += f"[Invalid atom nomenclature] {self.__getCurrentRestraint()}"\
                    f"{seqId2}:{compId2}:{atomId2} is invalid atom nomenclature.\n"
                continue

            for cifAtomId in _atomId2:
                atomSelection.append({'chain_id': chainId, 'seq_id': cifSeqId, 'comp_id': cifCompId, 'atom_id': cifAtomId})

                self.testCoordAtomIdConsistency(chainId, cifSeqId, cifCompId, cifAtomId, seqKey, coordAtomSite)

        if len(atomSelection) > 0:
            self.atomSelectionSet.append(atomSelection)

        if len(self.atomSelectionSet) < 2:
            return

        for atom1 in self.atomSelectionSet[0]:
            for atom2 in self.atomSelectionSet[1]:
                if self.__verbose:
                    print(f"subtype={self.__cur_subtype} id={self.distRestraints} "
                          f"atom1={atom1} atom2={atom2} {dstFunc}")

    def testCoordAtomIdConsistency(self, chainId, seqId, compId, atomId, seqKey, coordAtomSite):
        if not self.__hasCoord:
            return

        found = False

        if coordAtomSite is not None:
            if atomId in coordAtomSite['atom_id']:
                found = True
            elif 'alt_atom_id' in coordAtomSite and atomId in coordAtomSite['alt_atom_id']:
                found = True
                self.__authAtomId = 'auth_atom_id'
            elif self.__preferAuthSeq:
                _seqKey, _coordAtomSite = self.getCoordAtomSiteOf(chainId, seqId, asis=False)
                if _coordAtomSite is not None:
                    if atomId in _coordAtomSite['atom_id']:
                        found = True
                        self.__preferAuthSeq = False
                        self.__authSeqId = 'label_seq_id'
                        seqKey = _seqKey
                    elif 'alt_atom_id' in _coordAtomSite and atomId in _coordAtomSite['alt_atom_id']:
                        found = True
                        self.__preferAuthSeq = False
                        self.__authSeqId = 'label_seq_id'
                        self.__authAtomId = 'auth_atom_id'
                        seqKey = _seqKey

        elif self.__preferAuthSeq:
            _seqKey, _coordAtomSite = self.getCoordAtomSiteOf(chainId, seqId, asis=False)
            if _coordAtomSite is not None:
                if atomId in _coordAtomSite['atom_id']:
                    found = True
                    self.__preferAuthSeq = False
                    self.__authSeqId = 'label_seq_id'
                    seqKey = _seqKey
                elif 'alt_atom_id' in _coordAtomSite and atomId in _coordAtomSite['alt_atom_id']:
                    found = True
                    self.__preferAuthSeq = False
                    self.__authSeqId = 'label_seq_id'
                    self.__authAtomId = 'auth_atom_id'
                    seqKey = _seqKey

        if found:
            return

        if self.__ccU.updateChemCompDict(compId):
            cca = next((cca for cca in self.__ccU.lastAtomList if cca[self.__ccU.ccaAtomId] == atomId), None)
            if cca is not None and seqKey not in self.__coordUnobsRes:
                self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                    f"{chainId}:{seqId}:{compId}:{atomId} is not present in the coordinates.\n"

    def getCoordAtomSiteOf(self, chainId, seqId, cifCheck=True, asis=True):
        seqKey = (chainId, seqId)
        coordAtomSite = None
        if cifCheck:
            preferAuthSeq = self.__preferAuthSeq if asis else not self.__preferAuthSeq
            if preferAuthSeq:
                if seqKey in self.__coordAtomSite:
                    coordAtomSite = self.__coordAtomSite[seqKey]
            else:
                if seqKey in self.__labelToAuthSeq:
                    seqKey = self.__labelToAuthSeq[seqKey]
                    if seqKey in self.__coordAtomSite:
                        coordAtomSite = self.__coordAtomSite[seqKey]
        return seqKey, coordAtomSite

    # Enter a parse tree produced by CyanaMRParser#torsion_angle_restraints.
    def enterTorsion_angle_restraints(self, ctx: CyanaMRParser.Torsion_angle_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dihed'

    # Exit a parse tree produced by CyanaMRParser#torsion_angle_restraints.
    def exitTorsion_angle_restraints(self, ctx: CyanaMRParser.Torsion_angle_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#torsion_angle_restraint.
    def enterTorsion_angle_restraint(self, ctx: CyanaMRParser.Torsion_angle_restraintContext):  # pylint: disable=unused-argument
        self.dihedRestraints += 1

        self.atomSelectionSet = []

    # Exit a parse tree produced by CyanaMRParser#torsion_angle_restraint.
    def exitTorsion_angle_restraint(self, ctx: CyanaMRParser.Torsion_angle_restraintContext):  # pylint: disable=unused-argument
        if not self.__hasPolySeq:
            return

        seqId = int(str(ctx.Integer()))
        compId = str(ctx.Simple_name(0)).upper()
        angleName = str(ctx.Simple_name(1)).upper()
        lower_limit = float(str(ctx.Float(0)))
        upper_limit = float(str(ctx.Float(1)))

        if lower_limit > upper_limit:
            self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                f"The angle's lower limit '{lower_limit}' must be less than or equal to the upper limit '{upper_limit}'.\n"
            return

        if angleName not in KNOWN_ANGLE_NAMES:
            self.warningMessage += f"[Enumeration error] {self.__getCurrentRestraint()}"\
                f"The angle identifier '{str(ctx.Simple_name(1))}' is unknown.\n"
            return

        target_value = (upper_limit + lower_limit) / 2.0

        while target_value > 225.0:
            target_value -= 360.0
        while target_value < -225.0:
            target_value += 360.0

        validRange = True
        dstFunc = {'weight': 1.0}

        if target_value is not None:
            if ANGLE_ERROR_MIN < target_value < ANGLE_ERROR_MAX:
                dstFunc['target_value'] = f"{target_value:.3f}"

        if lower_limit is not None:
            if ANGLE_ERROR_MIN < lower_limit < ANGLE_ERROR_MAX:
                dstFunc['lower_limit'] = f"{lower_limit:.3f}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The lower limit value='{lower_limit}' must be within range {ANGLE_RESTRAINT_ERROR}.\n"

        if upper_limit is not None:
            if ANGLE_ERROR_MIN < upper_limit < ANGLE_ERROR_MAX:
                dstFunc['upper_limit'] = f"{upper_limit:.3f}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The upper limit value='{upper_limit}' must be within range {ANGLE_RESTRAINT_ERROR}.\n"

        if not validRange:
            return

        if target_value is not None:
            if ANGLE_RANGE_MIN <= target_value <= ANGLE_RANGE_MAX:
                pass

        if lower_limit is not None:
            if ANGLE_RANGE_MIN <= lower_limit <= ANGLE_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The lower limit value='{lower_limit}' should be within range {ANGLE_RESTRAINT_RANGE}.\n"

        if upper_limit is not None:
            if ANGLE_RANGE_MIN <= upper_limit <= ANGLE_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"The upper limit value='{upper_limit}' should be within range {ANGLE_RESTRAINT_RANGE}.\n"

        chainAssign = []

        atomId = ""

        for ps in self.__polySeq:
            chainId = ps['chain_id']
            if seqId in ps['seq_id']:
                cifCompId = ps['comp_id'][ps['seq_id'].index(seqId)]
                if cifCompId == compId:
                    chainAssign.append((chainId, seqId, cifCompId))
                elif len(self.__nefT.get_valid_star_atom(cifCompId, atomId)[0]) > 0:
                    chainAssign.append((chainId, seqId, cifCompId))

        if len(chainAssign) == 0 and self.__altPolySeq is not None:
            for ps in self.__altPolySeq:
                chainId = ps['chain_id']
                if seqId in ps['auth_seq_id']:
                    cifCompId = ps['comp_id'][ps['auth_seq_id'].index(seqId)]
                    cifSeqId = ps['seq_id'][ps['auth_seq_id'].index(seqId)]
                    chainAssign.append(chainId, cifSeqId, cifCompId)

        if len(chainAssign) == 0:
            self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                f"{seqId}:{compId} is not present in the coordinates.\n"
            return

        for chainId, cifSeqId, cifCompId in chainAssign:
            ps = next(ps for ps in self.__polySeq if ps['chain_id'] == chainId)

            peptide, nucleotide, _ = self.__csStat.getTypeOfCompId(cifCompId)

            atomNames = None
            seqOffset = None

            if nucleotide and angleName == 'CHI':
                if self.__ccU.updateChemCompDict(cifCompId):
                    try:
                        next(cca for cca in self.__ccU.lastAtomList if cca[self.__ccU.ccaAtomId] == 'N9')
                        atomNames = KNOWN_ANGLE_ATOM_NAMES['CHI']['R']
                        seqOffset = KNOWN_ANGLE_SEQ_OFFSET['CHI']['R']
                    except StopIteration:
                        atomNames = KNOWN_ANGLE_ATOM_NAMES['CHI']['Y']
                        seqOffset = KNOWN_ANGLE_SEQ_OFFSET['CHI']['Y']
            else:
                atomNames = KNOWN_ANGLE_ATOM_NAMES[angleName]
                seqOffset = KNOWN_ANGLE_SEQ_OFFSET[angleName]

            if peptide and angleName in ('PHI', 'PSI', 'OMEGA',
                                         'CHI1', 'CHI2', 'CHI3', 'CHI4', 'CHI5',
                                         'CHI21', 'CHI22', 'CHI31', 'CHI32', 'CHI42'):
                pass
            elif nucleotide and angleName in ('ALPHA', 'BETA', 'GAMMA', 'DELTA', 'EPSILON', 'ZETA',
                                              'CHI', 'ETA', 'THETA', "ETA'", "THETA'",
                                              'NU0', 'NU1', 'NU2', 'NU3', 'NU4',
                                              'TAU0', 'TAU1', 'TAU2', 'TAU3', 'TAU4'):
                pass
            else:
                self.warningMessage += f"[Enumeration error] {self.__getCurrentRestraint()}"\
                    f"The angle identifier {str(ctx.Simple_name(1))!r} did not match with residue {compId!r}.\n"
                return

            seqKey, coordAtomSite = self.getCoordAtomSiteOf(chainId, cifSeqId, self.__hasCoord)
            if 1 in seqOffset:
                nextSeqKey, nextCoordAtomSite = self.getCoordAtomSiteOf(chainId, cifSeqId + 1, self.__hasCoord)
            if -1 in seqOffset:
                prevSeqKey, prevCoordAtomSite = self.getCoordAtomSiteOf(chainId, cifSeqId - 1, self.__hasCoord)

            for atomId, offset in zip(atomNames, seqOffset):

                atomSelection = []

                _cifSeqId = cifSeqId + offset
                _cifCompId = cifCompId if offset == 0 else (ps['comp_id'][ps['seq_id'].index(_cifSeqId)] if _cifSeqId in ps['seq_id'] else None)

                if _cifCompId is None:
                    self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                        f"The sequence number '{seqId+offset}' is not present in polymer sequence of chain {chainId} of the coordinates.\n"
                    return

                self.__ccU.updateChemCompDict(_cifCompId)

                if isinstance(atomId, str):
                    cifAtomId = next((cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList if cca[self.__ccU.ccaAtomId] == atomId), None)
                else:
                    cifAtomId = next((cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList if atomId.match(cca[self.__ccU.ccaAtomId])), None)

                if cifAtomId is None:
                    self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                        f"{seqId+offset}:{compId}:{atomId} is not present in the coordinates.\n"
                    return

                atomSelection.append({'chain_id': chainId, 'seq_id': _cifSeqId, 'comp_id': _cifCompId, 'atom_id': cifAtomId})

                self.testCoordAtomIdConsistency(chainId, _cifSeqId, _cifCompId, cifAtomId,
                                                seqKey if offset == 0 else (nextSeqKey if offset == 1 else prevSeqKey),
                                                coordAtomSite if offset == 0 else (nextCoordAtomSite if offset == 1 else prevCoordAtomSite))

                if len(atomSelection) > 0:
                    self.atomSelectionSet.append(atomSelection)

            if len(self.atomSelectionSet) < 4:
                return

            for atom1 in self.atomSelectionSet[0]:
                for atom2 in self.atomSelectionSet[1]:
                    for atom3 in self.atomSelectionSet[2]:
                        for atom4 in self.atomSelectionSet[3]:
                            if self.__verbose:
                                print(f"subtype={self.__cur_subtype} id={self.dihedRestraints} angleName={angleName} "
                                      f"atom1={atom1} atom2={atom2} atom3={atom3} atom4={atom4} {dstFunc}")

            self.atomSelectionSet = []

    # Enter a parse tree produced by CyanaMRParser#rdc_restraints.
    def enterRdc_restraints(self, ctx: CyanaMRParser.Rdc_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'rdc'

    # Exit a parse tree produced by CyanaMRParser#rdc_restraints.
    def exitRdc_restraints(self, ctx: CyanaMRParser.Rdc_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#rdc_parameter.
    def enterRdc_parameter(self, ctx: CyanaMRParser.Rdc_parameterContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by CyanaMRParser#rdc_parameter.
    def exitRdc_parameter(self, ctx: CyanaMRParser.Rdc_parameterContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#rdc_restraint.
    def enterRdc_restraint(self, ctx: CyanaMRParser.Rdc_restraintContext):  # pylint: disable=unused-argument
        self.rdcRestraints += 1

    # Exit a parse tree produced by CyanaMRParser#rdc_restraint.
    def exitRdc_restraint(self, ctx: CyanaMRParser.Rdc_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#pcs_restraints.
    def enterPcs_restraints(self, ctx: CyanaMRParser.Pcs_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'pcs'

    # Exit a parse tree produced by CyanaMRParser#pcs_restraints.
    def exitPcs_restraints(self, ctx: CyanaMRParser.Pcs_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#pcs_parameter.
    def enterPcs_parameter(self, ctx: CyanaMRParser.Pcs_parameterContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by CyanaMRParser#pcs_parameter.
    def exitPcs_parameter(self, ctx: CyanaMRParser.Pcs_parameterContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by CyanaMRParser#pcs_restraint.
    def enterPcs_restraint(self, ctx: CyanaMRParser.Pcs_restraintContext):  # pylint: disable=unused-argument
        self.pcsRestraints += 1

    # Exit a parse tree produced by CyanaMRParser#pcs_restraint.
    def exitPcs_restraint(self, ctx: CyanaMRParser.Pcs_restraintContext):  # pylint: disable=unused-argument
        pass

    def __getCurrentRestraint(self):
        if self.__cur_subtype == 'dist':
            return f"[Check the {self.distRestraints}th row of distance restraints] "
        if self.__cur_subtype == 'dihed':
            return f"[Check the {self.dihedRestraints}th row of torsion angle restraints] "
        if self.__cur_subtype == 'rdc':
            return f"[Check the {self.rdcRestraints}th row of residual dipolar coupling restraints] "
        if self.__cur_subtype == 'pcs':
            return f"[Check the {self.pcsRestraints}th row of pseudocontact shift restraints] "
        return ''

    def getContentSubtype(self):
        """ Return content subtype of CYANA MR file.
        """

        contentSubtype = {'dist_restraint': self.distRestraints,
                          'dihed_restraint': self.dihedRestraints,
                          'rdc_restraint': self.rdcRestraints,
                          'pcs_restraint': self.pcsRestraints
                          }

        return {k: 1 for k, v in contentSubtype.items() if v > 0}

    def getCoordAtomSite(self):
        """ Return coordinates' atom name dictionary of each residue.
        """
        return self.__coordAtomSite

    def getCoordUnobsRes(self):
        """ Return catalog of unobserved residues of the coordinates.
        """
        return self.__coordUnobsRes

    def getLabelToAuthSeq(self):
        """ Return dictionary of differences between label_seq_id (as key) to auth_seq_id (as value).
        """
        return self.__labelToAuthSeq

# del CyanaMRParser
