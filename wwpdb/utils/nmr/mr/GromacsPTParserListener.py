##
# File: GromacsPTParserListener.py
# Date: 02-Jun-2022
#
# Updates:
# Generated from GromacsPTParser.g4 by ANTLR 4.10.1
""" ParserLister class for GROMACS PT files.
    @author: Masashi Yokochi
"""
import sys
import copy
import collections

from antlr4 import ParseTreeListener
from rmsd.calculate_rmsd import NAMES_ELEMENT  # noqa: F401 pylint: disable=no-name-in-module, import-error, unused-import

try:
    from wwpdb.utils.align.alignlib import PairwiseAlign  # pylint: disable=no-name-in-module
    from wwpdb.utils.nmr.mr.GromacsPTParser import GromacsPTParser
    from wwpdb.utils.nmr.mr.ParserListenerUtil import (checkCoordinates,
                                                       translateToStdAtomName,
                                                       translateToStdResName,
                                                       REPRESENTATIVE_MODEL_ID)
    from wwpdb.utils.nmr.ChemCompUtil import ChemCompUtil
    from wwpdb.utils.nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from wwpdb.utils.nmr.NEFTranslator.NEFTranslator import NEFTranslator
    from wwpdb.utils.nmr.AlignUtil import (hasLargeSeqGap,
                                           fillBlankCompIdWithOffset, beautifyPolySeq,
                                           getMiddleCode, getGaugeCode, getScoreOfSeqAlign,
                                           getOneLetterCodeSequence,
                                           letterToDigit, indexToLetter)
except ImportError:
    from nmr.align.alignlib import PairwiseAlign  # pylint: disable=no-name-in-module
    from nmr.mr.GromacsPTParser import GromacsPTParser
    from nmr.mr.ParserListenerUtil import (checkCoordinates,
                                           translateToStdAtomName,
                                           translateToStdResName,
                                           REPRESENTATIVE_MODEL_ID)
    from nmr.ChemCompUtil import ChemCompUtil
    from nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from nmr.NEFTranslator.NEFTranslator import NEFTranslator
    from nmr.AlignUtil import (hasLargeSeqGap,
                               fillBlankCompIdWithOffset, beautifyPolySeq,
                               getMiddleCode, getGaugeCode, getScoreOfSeqAlign,
                               getOneLetterCodeSequence,
                               letterToDigit, indexToLetter)


# This class defines a complete listener for a parse tree produced by GromacsPTParser.
class GromacsPTParserListener(ParseTreeListener):

    defaultStatements = 0
    moleculetypeStatements = 0
    atomtypesStatements = 0
    pairtypesStatements = 0
    bondtypesStatements = 0
    angletypesStatements = 0
    dihedraltypesStatements = 0
    constrainttypesStatements = 0
    nonbond_paramsStatements = 0
    atomsStatements = 0
    bondsStatements = 0
    pairsStatements = 0
    pairs_nbStatements = 0
    anglesStatements = 0
    dihedralsStatements = 0
    exclusionsStatements = 0
    constraintsStatements = 0
    settlesStatements = 0
    virtual_sites1Statements = 0
    virtual_sites2Statements = 0
    virtual_sites3Statements = 0
    virtual_sites4Statements = 0
    virtual_sitesnStatements = 0
    systemStatements = 0
    moleculesStatements = 0

    # criterion for low sequence coverage
    low_seq_coverage = 0.3

    # criterion for minimum sequence coverage when conflict occurs (NMR separated deposition)
    min_seq_coverage_w_conflict = 0.95

    # CCD accessing utility
    __ccU = None

    # BMRB chemical shift statistics
    __csStat = None

    # NEFTranslator
    __nefT = None

    # Pairwise align
    __pA = None

    # coordinates information generated by ParserListenerUtil.checkCoordinates()
    __polySeqModel = None
    __nonPolyModel = None

    __hasPolySeqModel = False

    # polymer sequence of GROMACS parameter/topology file
    __polySeqPrmTop = None

    __seqAlign = None
    __chainAssign = None

    # system
    __system = None

    # atoms
    __atoms = []

    # molecules
    __molecules = []

    # collection of number selection
    numberSelection = []

    # GROMACS atom number dictionary
    __atomNumberDict = None

    # __cur_column_len = None
    __cur_word_len = None

    warningMessage = ''

    def __init__(self, verbose=True, log=sys.stdout,
                 representativeModelId=REPRESENTATIVE_MODEL_ID,
                 cR=None, cC=None, ccU=None, csStat=None, nefT=None):

        if cR is not None:
            ret = checkCoordinates(verbose, log, representativeModelId, cR, cC, testTag=False)
            self.__polySeqModel = ret['polymer_sequence']
            self.__nonPolyModel = ret['non_polymer']

        self.__hasPolySeqModel = self.__polySeqModel is not None and len(self.__polySeqModel) > 0

        # CCD accessing utility
        self.__ccU = ChemCompUtil(verbose, log) if ccU is None else ccU

        # BMRB chemical shift statistics
        self.__csStat = BMRBChemShiftStat(verbose, log, self.__ccU) if csStat is None else csStat

        # NEFTranslator
        self.__nefT = NEFTranslator(verbose, log, self.__ccU, self.__csStat) if nefT is None else nefT

        # Pairwise align
        if self.__hasPolySeqModel:
            self.__pA = PairwiseAlign()
            self.__pA.setVerbose(verbose)

    # Enter a parse tree produced by GromacsPTParser#gromacs_pt.
    def enterGromacs_pt(self, ctx: GromacsPTParser.Gromacs_ptContext):  # pylint: disable=unused-argument
        self.__atomNumberDict = {}
        self.__polySeqPrmTop = []

    # Exit a parse tree produced by GromacsPTParser#gromacs_pt.
    def exitGromacs_pt(self, ctx: GromacsPTParser.Gromacs_ptContext):  # pylint: disable=unused-argument
        if not self.__hasPolySeqModel:
            if len(self.warningMessage) == 0:
                self.warningMessage = None
            else:
                self.warningMessage = self.warningMessage[0:-1]
                self.warningMessage = '\n'.join(set(self.warningMessage.split('\n')))
            return

        if len(self.__atoms) == 0:
            return

        chainIndex = letterToDigit(self.__polySeqModel[0]['chain_id']) - 1  # set tentative chain_id from label_asym_id, which will be assigned to coordinate auth_asym_id
        chainId = indexToLetter(chainIndex)

        terminus = [atom['auth_atom_id'].endswith('T') for atom in self.__atoms]

        atomTotal = len(self.__atoms)
        if terminus[0]:
            terminus[0] = False
        for i in range(0, atomTotal - 1):
            j = i + 1
            if terminus[i] and terminus[j]:
                terminus[i] = False
        if terminus[-1]:
            terminus[-1] = False

        seqIdList = []
        compIdList = []

        NON_METAL_ELEMENTS = ('H', 'C', 'N', 'O', 'P', 'S')

        prevAtomName = ''
        prevSeqId = None
        offset = 0
        for atom in self.__atoms:
            atomNum = atom['atom_number']
            atomName = atom['auth_atom_id']
            atomType = atom['atom_type']
            _seqId = atom['auth_seq_id']
            compId = atom['auth_comp_id']
            # the second condition indicates metal ions
            if terminus[atomNum - 2]\
               or (compId == atomName and compId.title() in NAMES_ELEMENT)\
               or (len(prevAtomName) > 0 and prevAtomName[0] not in NON_METAL_ELEMENTS and prevSeqId != _seqId):
                self.__polySeqPrmTop.append({'chain_id': chainId,
                                             'seq_id': seqIdList,
                                             'auth_comp_id': compIdList})
                seqIdList = []
                compIdList = []
                chainIndex += 1
                chainId = indexToLetter(chainIndex)
                offset = 1 - _seqId
            seqId = _seqId + offset
            if seqId not in seqIdList:
                seqIdList.append(seqId)
                compIdList.append(compId)
            self.__atomNumberDict[atomNum] = {'chain_id': chainId,
                                              'seq_id': seqId,
                                              'auth_comp_id': compId,
                                              'auth_atom_id': atomName,
                                              'atom_type': atomType}
            prevAtomName = atomName
            prevSeqId = _seqId

        self.__polySeqPrmTop.append({'chain_id': chainId,
                                     'seq_id': seqIdList,
                                     'auth_comp_id': compIdList})

        for ps in self.__polySeqPrmTop:
            chainId = ps['chain_id']
            compIdList = []
            for seqId, authCompId in zip(ps['seq_id'], ps['auth_comp_id']):
                authAtomIds = [atomNum['auth_atom_id'] for atomNum in self.__atomNumberDict.values()
                               if atomNum['chain_id'] == chainId
                               and atomNum['seq_id'] == seqId
                               and atomNum['auth_atom_id'][0] != 'H']
                authCompId = translateToStdResName(authCompId)
                if self.__ccU.updateChemCompDict(authCompId):
                    chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]
                    valid = True
                    for _atomId in authAtomIds:
                        if _atomId not in chemCompAtomIds:
                            valid = False
                            break
                        if not valid:
                            break
                    if valid:
                        compIdList.append(authCompId)
                        for atomNum in self.__atomNumberDict.values():
                            if atomNum['chain_id'] == chainId and atomNum['seq_id'] == seqId:
                                atomNum['comp_id'] = authCompId
                                atomNum['atom_id'] = atomNum['auth_atom_id']
                                if 'atom_type' in atomNum:
                                    del atomNum['atom_type']
                    else:
                        compId = self.__csStat.getSimilarCompIdFromAtomIds([atomNum['auth_atom_id']
                                                                            for atomNum in self.__atomNumberDict.values()
                                                                            if atomNum['chain_id'] == chainId
                                                                            and atomNum['seq_id'] == seqId])
                        if compId is not None:
                            compIdList.append(compId)
                            chemCompAtomIds = None
                            if self.__ccU.updateChemCompDict(compId):
                                chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]
                            for atomNum in self.__atomNumberDict.values():
                                if atomNum['chain_id'] == chainId and atomNum['seq_id'] == seqId:
                                    atomNum['comp_id'] = compId
                                    if chemCompAtomIds is not None and atomNum['auth_atom_id'] in chemCompAtomIds:
                                        atomNum['atom_id'] = atomNum['auth_atom_id']
                                        if 'atom_type' in atomNum:
                                            del atomNum['atom_type']
                        else:
                            compIdList.append('.')
                            unknownAtomIds = [_atomId for _atomId in authAtomIds if _atomId not in chemCompAtomIds]
                            self.warningMessage += f"[Unknown atom name] "\
                                f"{unknownAtomIds} are unknown atom names for {authCompId} residue.\n"
                            compIdList.append(f"? {authCompId} {unknownAtomIds}")
                else:
                    compId = self.__csStat.getSimilarCompIdFromAtomIds([atomNum['auth_atom_id']
                                                                        for atomNum in self.__atomNumberDict.values()
                                                                        if atomNum['chain_id'] == chainId
                                                                        and atomNum['seq_id'] == seqId])
                    if compId is not None:
                        compIdList.append(compId)
                        chemCompAtomIds = None
                        if self.__ccU.updateChemCompDict(compId):
                            chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]
                        for atomNum in self.__atomNumberDict.values():
                            if atomNum['chain_id'] == chainId and atomNum['seq_id'] == seqId:
                                atomNum['comp_id'] = compId
                                if chemCompAtomIds is not None and atomNum['auth_atom_id'] in chemCompAtomIds:
                                    atomNum['atom_id'] = atomNum['auth_atom_id']
                                    if 'atom_type' in atomNum:
                                        del atomNum['atom_type']
                    else:
                        compIdList.append('.')
                        """ deferred to assignNonPolymer()
                        self.warningMessage += f"[Unknown residue name] "\
                            f"{authCompId!r} is unknown residue name.\n"
                        """

            ps['comp_id'] = compIdList

        for atomNum in self.__atomNumberDict.values():
            if 'comp_id' in atomNum and atomNum['comp_id'] != atomNum['auth_comp_id']\
               and 'atom_id' not in atomNum:
                if self.__ccU.updateChemCompDict(atomNum['comp_id']):
                    chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]

                    atomId = translateToStdAtomName(atomNum['auth_atom_id'], atomNum['comp_id'], chemCompAtomIds)

                    if atomId is not None and atomId in chemCompAtomIds:
                        atomNum['atom_id'] = atomId
                        if 'atom_type' in atomNum:
                            del atomNum['atom_type']
                    elif atomNum['comp_id'] != atomNum['auth_comp_id']:
                        authCompId = translateToStdResName(atomNum['auth_comp_id'])
                        if self.__ccU.updateChemCompDict(authCompId):
                            chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]

                            atomId = translateToStdAtomName(atomNum['auth_atom_id'], authCompId, chemCompAtomIds)

                            if atomId is not None and atomId in chemCompAtomIds:
                                atomNum['atom_id'] = atomId
                                if 'atom_type' in atomNum:
                                    del atomNum['atom_type']
            else:
                authCompId = translateToStdResName(atomNum['auth_comp_id'])
                if self.__ccU.updateChemCompDict(authCompId):
                    atomIds = self.__nefT.get_valid_star_atom_in_xplor(authCompId, atomNum['auth_atom_id'])[0]
                    if len(atomIds) == 1:
                        atomNum['atom_id'] = atomIds[0]
                        if 'atom_type' in atomNum:
                            del atomNum['atom_type']

        for atomNum in self.__atomNumberDict.values():
            if 'atom_id' not in atomNum:
                if 'comp_id' not in atomNum or atomNum['comp_id'] == atomNum['auth_comp_id']:
                    authCompId = translateToStdResName(atomNum['auth_comp_id'])
                    if self.__ccU.updateChemCompDict(authCompId):
                        self.warningMessage += f"[Unknown atom name] "\
                            f"{atomNum['auth_atom_id']!r} is not recognized as the atom name of {atomNum['auth_comp_id']!r} residue.\n"
                else:
                    authCompId = translateToStdResName(atomNum['auth_comp_id'])
                    if self.__ccU.updateChemCompDict(authCompId):
                        self.warningMessage += f"[Unknown atom name] "\
                            f"{atomNum['auth_atom_id']!r} is not recognized as the atom name of {atomNum['comp_id']!r} residue "\
                            f"(the original residue label is {atomNum['auth_comp_id']!r}).\n"

        self.alignPolymerSequence()
        self.assignPolymerSequence()

        if self.__chainAssign is not None:

            chain_mapping = {}

            for chain_assign in self.__chainAssign:
                ref_chain_id = chain_assign['ref_chain_id']
                test_chain_id = chain_assign['test_chain_id']

                if ref_chain_id != test_chain_id:
                    chain_mapping[test_chain_id] = ref_chain_id

            if len(chain_mapping) > 0:

                for ps in self.__polySeqPrmTop:
                    if ps['chain_id'] in chain_mapping:
                        ps['chain_id'] = chain_mapping[ps['chain_id']]

                for atomNum in self.__atomNumberDict.values():
                    if atomNum['chain_id'] in chain_mapping:
                        atomNum['chain_id'] = chain_mapping[atomNum['chain_id']]

                self.alignPolymerSequence()
                self.assignPolymerSequence()

            self.trimPolymerSequence()

            if self.__nonPolyModel is not None:

                # metal ion
                if any(ps for ps in self.__polySeqPrmTop
                       if len(ps['seq_id']) == 1 and ps['comp_id'][0].title() in NAMES_ELEMENT):
                    self.assignMetalIon()

                # other non-polymer
                nonPolyIndices = [idx for idx, ps in enumerate(self.__polySeqPrmTop)
                                  if not any(chain_assign for chain_assign in self.__chainAssign
                                             if chain_assign['test_chain_id'] == ps['chain_id'])
                                  and len(set(ps['comp_id'])) == 1 and ps['comp_id'][0] == '.']

                if len(nonPolyIndices) > 0:
                    self.assignNonPolymer(nonPolyIndices)

                    for idx in sorted(nonPolyIndices, reverse=True):
                        del self.__polySeqPrmTop[idx]

        if len(self.warningMessage) == 0:
            self.warningMessage = None
        else:
            self.warningMessage = self.warningMessage[0:-1]
            self.warningMessage = '\n'.join(set(self.warningMessage.split('\n')))

    def alignPolymerSequence(self):
        if not self.__hasPolySeqModel or self.__polySeqPrmTop is None:
            return

        self.__seqAlign = []

        for s1 in self.__polySeqModel:
            chain_id = s1['auth_chain_id']

            for s2 in self.__polySeqPrmTop:
                chain_id2 = s2['chain_id']

                self.__pA.setReferenceSequence(s1['comp_id'], 'REF' + chain_id)
                self.__pA.addTestSequence(s2['comp_id'], chain_id)
                self.__pA.doAlign()

                myAlign = self.__pA.getAlignment(chain_id)

                length = len(myAlign)

                if length == 0:
                    continue

                _matched, unmapped, conflict, offset_1, offset_2 = getScoreOfSeqAlign(myAlign)

                if length == unmapped + conflict or _matched <= conflict:
                    continue

                _s1 = s1 if offset_1 == 0 else fillBlankCompIdWithOffset(s1, offset_1)
                _s2 = s2 if offset_2 == 0 else fillBlankCompIdWithOffset(s2, offset_2)

                if conflict > 0 and hasLargeSeqGap(_s1, _s2):
                    __s1, __s2 = beautifyPolySeq(_s1, _s2)
                    _s1_ = __s1
                    _s2_ = __s2

                    self.__pA.setReferenceSequence(_s1_['comp_id'], 'REF' + chain_id)
                    self.__pA.addTestSequence(_s2_['comp_id'], chain_id)
                    self.__pA.doAlign()

                    myAlign = self.__pA.getAlignment(chain_id)

                    length = len(myAlign)

                    _matched, unmapped, _conflict, _offset_1, _offset_2 = getScoreOfSeqAlign(myAlign)

                    if _conflict == 0 and len(__s2['comp_id']) - len(s2['comp_id']) == conflict:
                        conflict = 0
                        offset_1 = _offset_1
                        offset_2 = _offset_2
                        _s1 = __s1
                        _s2 = __s2

                ref_length = len(s1['seq_id'])

                ref_code = getOneLetterCodeSequence(_s1['comp_id'])
                test_code = getOneLetterCodeSequence(_s2['comp_id'])
                mid_code = getMiddleCode(ref_code, test_code)
                ref_gauge_code = getGaugeCode(_s1['seq_id'])
                test_gauge_code = getGaugeCode(_s2['seq_id'])

                if any((__s1, __s2) for (__s1, __s2, __c1, __c2)
                       in zip(_s1['seq_id'], _s2['seq_id'], _s1['comp_id'], _s2['comp_id'])
                       if __c1 != '.' and __c2 != '.' and __c1 != __c2):
                    seq_id1 = []
                    seq_id2 = []
                    comp_id1 = []
                    comp_id2 = []
                    idx1 = 0
                    idx2 = 0
                    for i in range(length):
                        myPr = myAlign[i]
                        myPr0 = str(myPr[0])
                        myPr1 = str(myPr[1])
                        if myPr0 != '.':
                            while idx1 < len(_s1['seq_id']):
                                if _s1['comp_id'][idx1] == myPr0:
                                    seq_id1.append(_s1['seq_id'][idx1])
                                    comp_id1.append(myPr0)
                                    idx1 += 1
                                    break
                                idx1 += 1
                        else:
                            seq_id1.append(None)
                            comp_id1.append('.')
                        if myPr1 != '.':
                            while idx2 < len(_s2['seq_id']):
                                if _s2['comp_id'][idx2] == myPr1:
                                    seq_id2.append(_s2['seq_id'][idx2])
                                    comp_id2.append(myPr1)
                                    idx2 += 1
                                    break
                                idx2 += 1
                        else:
                            seq_id2.append(None)
                            comp_id2.append('.')
                    ref_code = getOneLetterCodeSequence(comp_id1)
                    test_code = getOneLetterCodeSequence(comp_id2)
                    mid_code = getMiddleCode(ref_code, test_code)
                    ref_gauge_code = getGaugeCode(seq_id1, offset_1)
                    test_gauge_code = getGaugeCode(seq_id2, offset_2)
                    if ' ' in ref_gauge_code:
                        for p, g in enumerate(ref_gauge_code):
                            if g == ' ':
                                ref_code = ref_code[0:p] + '-' + ref_code[p + 1:]
                    if ' ' in test_gauge_code:
                        for p, g in enumerate(test_gauge_code):
                            if g == ' ':
                                test_code = test_code[0:p] + '-' + test_code[p + 1:]

                matched = mid_code.count('|')

                seq_align = {'ref_chain_id': chain_id, 'test_chain_id': chain_id2, 'length': ref_length,
                             'matched': matched, 'conflict': conflict, 'unmapped': unmapped,
                             'sequence_coverage': float(f"{float(length - (unmapped + conflict)) / ref_length:.3f}"),
                             'ref_seq_id': _s1['seq_id'], 'test_seq_id': _s2['seq_id'],
                             'ref_gauge_code': ref_gauge_code, 'ref_code': ref_code, 'mid_code': mid_code,
                             'test_code': test_code, 'test_gauge_code': test_gauge_code}

                self.__seqAlign.append(seq_align)

    def assignPolymerSequence(self):
        if self.__seqAlign is None:
            return

        top_chains = len(self.__polySeqPrmTop)

        mat = []
        indices = []

        for s1 in self.__polySeqModel:
            chain_id = s1['auth_chain_id']

            cost = [0 for i in range(top_chains)]

            for s2 in self.__polySeqPrmTop:
                chain_id2 = s2['chain_id']

                result = next((seq_align for seq_align in self.__seqAlign
                               if seq_align['ref_chain_id'] == chain_id
                               and seq_align['test_chain_id'] == chain_id2), None)

                if result is not None:
                    cost[self.__polySeqPrmTop.index(s2)] = result['unmapped'] + result['conflict'] - result['length']
                    if result['length'] >= len(s1['seq_id']) - result['unmapped']:
                        indices.append((self.__polySeqModel.index(s1), self.__polySeqPrmTop.index(s2)))

            mat.append(cost)

        self.__chainAssign = []

        for row, column in indices:

            if mat[row][column] >= 0:
                _cif_chains = []
                for _row, _column in indices:
                    if column == _column:
                        _cif_chains.append(self.__polySeqModel[_row]['auth_chain_id'])

                if len(_cif_chains) > 1:
                    chain_id2 = self.__polySeqPrmTop[column]['chain_id']

                    self.warningMessage += f"[Concatenated sequence] The chain ID {chain_id2!r} of the sequences in the GROMACS parameter/topology file "\
                        f"will be re-assigned to the chain IDs {_cif_chains} in the coordinates during biocuration.\n"

            chain_id = self.__polySeqModel[row]['auth_chain_id']
            chain_id2 = self.__polySeqPrmTop[column]['chain_id']

            result = next(seq_align for seq_align in self.__seqAlign
                          if seq_align['ref_chain_id'] == chain_id and seq_align['test_chain_id'] == chain_id2)

            chain_assign = {'ref_chain_id': chain_id, 'test_chain_id': chain_id2, 'length': result['length'],
                            'matched': result['matched'], 'conflict': result['conflict'], 'unmapped': result['unmapped'],
                            'sequence_coverage': result['sequence_coverage']}

            s1 = next(s for s in self.__polySeqModel if s['auth_chain_id'] == chain_id)
            s2 = next(s for s in self.__polySeqPrmTop if s['chain_id'] == chain_id2)

            self.__pA.setReferenceSequence(s1['comp_id'], 'REF' + chain_id)
            self.__pA.addTestSequence(s2['comp_id'], chain_id)
            self.__pA.doAlign()

            myAlign = self.__pA.getAlignment(chain_id)

            length = len(myAlign)

            _matched, unmapped, conflict, offset_1, offset_2 = getScoreOfSeqAlign(myAlign)

            _s1 = s1 if offset_1 == 0 else fillBlankCompIdWithOffset(s1, offset_1)
            _s2 = s2 if offset_2 == 0 else fillBlankCompIdWithOffset(s2, offset_2)

            if conflict > 0 and hasLargeSeqGap(_s1, _s2):
                __s1, __s2 = beautifyPolySeq(_s1, _s2)
                _s1 = __s1
                _s2 = __s2

                self.__pA.setReferenceSequence(_s1['comp_id'], 'REF' + chain_id)
                self.__pA.addTestSequence(_s2['comp_id'], chain_id)
                self.__pA.doAlign()

                myAlign = self.__pA.getAlignment(chain_id)

                length = len(myAlign)

                _matched, unmapped, _conflict, _, _ = getScoreOfSeqAlign(myAlign)

                if _conflict == 0 and len(__s2['comp_id']) - len(s2['comp_id']) == conflict:
                    result['conflict'] = 0
                    s2 = __s2

            if result['unmapped'] > 0 or result['conflict'] > 0:

                aligned = [True] * length
                seq_id1 = []
                seq_id2 = []

                j = 0
                for i in range(length):
                    if str(myAlign[i][0]) != '.':
                        seq_id1.append(s1['seq_id'][j])
                        j += 1
                    else:
                        seq_id1.append(None)

                j = 0
                for i in range(length):
                    if str(myAlign[i][1]) != '.':
                        seq_id2.append(s2['seq_id'][j])
                        j += 1
                    else:
                        seq_id2.append(None)

                for i in range(length):
                    myPr = myAlign[i]
                    myPr0 = str(myPr[0])
                    myPr1 = str(myPr[1])
                    if myPr0 == '.' or myPr1 == '.':
                        aligned[i] = False
                    elif myPr0 != myPr1:
                        pass
                    else:
                        break

                for i in reversed(range(length)):
                    myPr = myAlign[i]
                    myPr0 = str(myPr[0])
                    myPr1 = str(myPr[1])
                    if myPr0 == '.' or myPr1 == '.':
                        aligned[i] = False
                    elif myPr0 != myPr1:
                        pass
                    else:
                        break

                _conflicts = 0

                for i in range(length):
                    myPr = myAlign[i]
                    if myPr[0] == myPr[1]:
                        continue

                    cif_comp_id = str(myPr[0])
                    top_comp_id = str(myPr[1])

                    if top_comp_id == '.' and cif_comp_id != '.':
                        pass

                    elif top_comp_id != cif_comp_id and aligned[i]:
                        _conflicts += 1

                if _conflicts > chain_assign['unmapped'] and chain_assign['sequence_coverage'] < self.min_seq_coverage_w_conflict:
                    continue

                if _conflicts + offset_1 > _matched and chain_assign['sequence_coverage'] < self.low_seq_coverage:  # DAOTHER-7825 (2lyw)
                    continue

                unmapped = []
                conflict = []

                for i in range(length):
                    myPr = myAlign[i]
                    if myPr[0] == myPr[1]:
                        continue

                    cif_comp_id = str(myPr[0])
                    top_comp_id = str(myPr[1])

                    if top_comp_id == '.' and cif_comp_id != '.':

                        unmapped.append({'ref_seq_id': seq_id1[i], 'ref_comp_id': cif_comp_id})
                        """ unmapped residue is not error
                        if not aligned[i]:

                            if not self.__ccU.updateChemCompDict(cif_comp_id):
                                continue

                            if self.__ccU.lastChemCompDict['_chem_comp.pdbx_release_status'] != 'REL':
                                continue

                            cif_seq_code = f"{chain_id}:{seq_id1[i]}:{cif_comp_id}"

                            self.warningMessage += f"[Sequence mismatch] {cif_seq_code} is not present "\
                                f"in the GROMACS parameter/topology data (chain_id {chain_id2}).\n"
                        """
                    elif top_comp_id != cif_comp_id and aligned[i]:

                        conflict.append({'ref_seq_id': seq_id1[i], 'ref_comp_id': cif_comp_id,
                                         'test_seq_id': seq_id2[i], 'test_comp_id': top_comp_id})

                        cif_seq_code = f"{chain_id}:{seq_id1[i]}:{cif_comp_id}"
                        if cif_comp_id == '.':
                            cif_seq_code += ', insertion error'
                        top_seq_code = f"{chain_id2}:{seq_id2[i]}:{top_comp_id}"
                        if top_comp_id == '.':
                            top_seq_code += ', insertion error'

                        if cif_comp_id != '.':

                            if not self.__ccU.updateChemCompDict(cif_comp_id):
                                continue

                            if self.__ccU.lastChemCompDict['_chem_comp.pdbx_release_status'] != 'REL':
                                continue

                        self.warningMessage += f"[Sequence mismatch] Sequence alignment error between the coordinate ({cif_seq_code}) "\
                            f"and the GROMACS parameter/topology data ({top_seq_code}). "\
                            "Please verify the two sequences and re-upload the correct file(s) if required.\n"

                if len(unmapped) > 0:
                    chain_assign['unmapped_sequence'] = unmapped

                if len(conflict) > 0:
                    chain_assign['conflict_sequence'] = conflict
                    chain_assign['conflict'] = len(conflict)
                    chain_assign['unmapped'] = chain_assign['unmapped'] - len(conflict)
                    if chain_assign['unmapped'] < 0:
                        chain_assign['conflict'] -= chain_assign['unmapped']
                        chain_assign['unmapped'] = 0

                    result['conflict'] = chain_assign['conflict']
                    result['unmapped'] = chain_assign['unmapped']

            self.__chainAssign.append(chain_assign)

        if len(self.__chainAssign) > 0:

            if len(self.__polySeqModel) > 1:

                if any(s for s in self.__polySeqModel if 'identical_chain_id' in s):

                    for chain_assign in self.__chainAssign:

                        if chain_assign['conflict'] > 0:
                            continue

                        chain_id = chain_assign['ref_chain_id']

                        try:
                            identity = next(s['identical_chain_id'] for s in self.__polySeqModel
                                            if s['auth_chain_id'] == chain_id and 'identical_chain_id' in s)

                            for chain_id in identity:

                                if not any(_chain_assign for _chain_assign in self.__chainAssign if _chain_assign['ref_chain_id'] == chain_id):
                                    _chain_assign = copy.copy(chain_assign)
                                    _chain_assign['ref_chain_id'] = chain_id
                                    self.__chainAssign.append(_chain_assign)

                        except StopIteration:
                            pass

    def trimPolymerSequence(self):
        if self.__seqAlign is None or self.__chainAssign is None:
            return

        uneffSeqAlignIdx = list(range(len(self.__seqAlign) - 1, -1, -1))

        for chain_assign in self.__chainAssign:
            ref_chain_id = chain_assign['ref_chain_id']
            test_chain_id = chain_assign['test_chain_id']

            effSeqAligIdx = next((idx for idx, seq_align in enumerate(self.__seqAlign)
                                  if seq_align['ref_chain_id'] == ref_chain_id
                                  and seq_align['test_chain_id'] == test_chain_id), None)

            if effSeqAligIdx is not None:
                uneffSeqAlignIdx.remove(effSeqAligIdx)

        if len(uneffSeqAlignIdx) > 0:
            for idx in uneffSeqAlignIdx:
                del self.__seqAlign[idx]

    def assignMetalIon(self):
        if self.__nonPolyModel is None:
            return

        metals = collections.Counter(s2['comp_id'][0] for s2 in self.__polySeqPrmTop
                                     if len(s2['seq_id']) == 1 and s2['comp_id'][0].title() in NAMES_ELEMENT).most_common()

        for metal in metals:
            compId = metal[0]

            atomNums = [atomNum for atomNum in self.__atomNumberDict.values()
                        if atomNum['auth_comp_id'] == compId and atomNum['auth_atom_id'] == compId]

            nonPolys = [nonPoly for nonPoly in self.__nonPolyModel
                        if nonPoly['comp_id'][0] == compId]

            for atomNum, nonPoly in zip(atomNums, nonPolys):
                atomNum['chain_id'] = nonPoly['auth_chain_id']
                atomNum['seq_id'] = nonPoly['auth_seq_id'][0]

    def assignNonPolymer(self, nonPolyIndices):
        if self.__nonPolyModel is None:
            return

        authCompIds = []

        for idx, ps in enumerate(self.__polySeqPrmTop):
            if idx not in nonPolyIndices:
                continue
            for authCompId, compId in zip(ps['auth_comp_id'], ps['comp_id']):
                if compId != '.':
                    continue
                authCompIds.append(authCompId)

        nonPolyCompIds = collections.Counter(authCompIds).most_common()

        compIds = []
        for nonPoly in self.__nonPolyModel:
            compId = nonPoly['comp_id'][0]
            if compId.title() in NAMES_ELEMENT:
                continue
            compIds.append(compId)

        refCompIds = collections.Counter(compIds).most_common()

        comp_id_mapping = {}

        for authCompId in nonPolyCompIds:
            refCompId = next((compId[0] for compId in refCompIds if compId[1] == authCompId[1] and compId[1] not in comp_id_mapping.values()), None)
            if refCompId is None:
                self.warningMessage += f"[Unknown residue name] "\
                    f"{authCompId[0]!r} is unknown residue name.\n"
                continue
            comp_id_mapping[authCompId[0]] = refCompId

        for authCompId, compId in comp_id_mapping.items():
            chemCompAtomIds = None
            if self.__ccU.updateChemCompDict(compId):
                chemCompAtomIds = [cca[self.__ccU.ccaAtomId] for cca in self.__ccU.lastAtomList]

            authSeqKeys = []

            for idx, ps in enumerate(self.__polySeqPrmTop):
                if idx not in nonPolyIndices:
                    continue
                _chainId = ps['chain_id']
                for _authCompId, _compId, _seqId in zip(ps['auth_comp_id'], ps['comp_id'], ps['seq_id']):
                    if _authCompId != authCompId or _compId != '.':
                        continue
                    authSeqKeys.append((_chainId, _seqId))

            nonPolys = [nonPoly for nonPoly in self.__nonPolyModel
                        if nonPoly['comp_id'][0] == compId]

            reported_auth_atom_id = []

            for authSeqKey, nonPoly in zip(authSeqKeys, nonPolys):
                atomNums = [atomNum for atomNum in self.__atomNumberDict.values()
                            if atomNum['chain_id'] == authSeqKey[0] and atomNum['seq_id'] == authSeqKey[1]]

                for atomNum in atomNums:
                    atomNum['chain_id'] = nonPoly['auth_chain_id']
                    atomNum['seq_id'] = nonPoly['auth_seq_id'][0]
                    atomNum['comp_id'] = compId
                    authAtomId = atomNum['auth_atom_id']
                    if chemCompAtomIds is not None and authAtomId in chemCompAtomIds:
                        atomNum['atom_id'] = authAtomId
                    else:
                        if authAtomId not in reported_auth_atom_id:
                            self.warningMessage += f"[Unknown atom name] "\
                                f"{authAtomId!r} is not recognized as the atom name of {compId!r} residue "\
                                f"(the original residue label is {authCompId!r}).\n"
                            reported_auth_atom_id.append(authAtomId)

    # Enter a parse tree produced by GromacsPTParser#default_statement.
    def enterDefault_statement(self, ctx: GromacsPTParser.Default_statementContext):  # pylint: disable=unused-argument
        self.defaultStatements += 1

    # Exit a parse tree produced by GromacsPTParser#default_statement.
    def exitDefault_statement(self, ctx: GromacsPTParser.Default_statementContext):
        if ctx.Integer(0):
            return
        self.defaultStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#moleculetype_statement.
    def enterMoleculetype_statement(self, ctx: GromacsPTParser.Moleculetype_statementContext):  # pylint: disable=unused-argument
        self.moleculetypeStatements += 1

    # Exit a parse tree produced by GromacsPTParser#moleculetype_statement.
    def exitMoleculetype_statement(self, ctx: GromacsPTParser.Moleculetype_statementContext):
        if ctx.moleculetype(0):
            return
        self.moleculetypeStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#moleculetype.
    def enterMoleculetype(self, ctx: GromacsPTParser.MoleculetypeContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#moleculetype.
    def exitMoleculetype(self, ctx: GromacsPTParser.MoleculetypeContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#atomtypes_statement.
    def enterAtomtypes_statement(self, ctx: GromacsPTParser.Atomtypes_statementContext):  # pylint: disable=unused-argument
        self.atomtypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#atomtypes_statement.
    def exitAtomtypes_statement(self, ctx: GromacsPTParser.Atomtypes_statementContext):
        if ctx.atomtypes(0):
            return
        self.atomtypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#atomtypes.
    def enterAtomtypes(self, ctx: GromacsPTParser.AtomtypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#atomtypes.
    def exitAtomtypes(self, ctx: GromacsPTParser.AtomtypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#pairtypes_statement.
    def enterPairtypes_statement(self, ctx: GromacsPTParser.Pairtypes_statementContext):  # pylint: disable=unused-argument
        self.pairtypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#pairtypes_statement.
    def exitPairtypes_statement(self, ctx: GromacsPTParser.Pairtypes_statementContext):
        if ctx.pairtypes(0):
            return
        self.pairtypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#pairtypes.
    def enterPairtypes(self, ctx: GromacsPTParser.PairtypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#pairtypes.
    def exitPairtypes(self, ctx: GromacsPTParser.PairtypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#bondtypes_statement.
    def enterBondtypes_statement(self, ctx: GromacsPTParser.Bondtypes_statementContext):  # pylint: disable=unused-argument
        self.bondtypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#bondtypes_statement.
    def exitBondtypes_statement(self, ctx: GromacsPTParser.Bondtypes_statementContext):
        if ctx.bondtypes(0):
            return
        self.bondtypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#bondtypes.
    def enterBondtypes(self, ctx: GromacsPTParser.BondtypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#bondtypes.
    def exitBondtypes(self, ctx: GromacsPTParser.BondtypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#angletypes_statement.
    def enterAngletypes_statement(self, ctx: GromacsPTParser.Angletypes_statementContext):  # pylint: disable=unused-argument
        self.angletypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#angletypes_statement.
    def exitAngletypes_statement(self, ctx: GromacsPTParser.Angletypes_statementContext):
        if ctx.angletypes(0):
            return
        self.angletypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#angletypes.
    def enterAngletypes(self, ctx: GromacsPTParser.AngletypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#angletypes.
    def exitAngletypes(self, ctx: GromacsPTParser.AngletypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#dihedraltypes_statement.
    def enterDihedraltypes_statement(self, ctx: GromacsPTParser.Dihedraltypes_statementContext):  # pylint: disable=unused-argument
        self.dihedraltypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#dihedraltypes_statement.
    def exitDihedraltypes_statement(self, ctx: GromacsPTParser.Dihedraltypes_statementContext):
        if ctx.dihedraltypes(0):
            return
        self.dihedraltypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#dihedraltypes.
    def enterDihedraltypes(self, ctx: GromacsPTParser.DihedraltypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#dihedraltypes.
    def exitDihedraltypes(self, ctx: GromacsPTParser.DihedraltypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#constrainttypes_statement.
    def enterConstrainttypes_statement(self, ctx: GromacsPTParser.Constrainttypes_statementContext):  # pylint: disable=unused-argument
        self.constrainttypesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#constrainttypes_statement.
    def exitConstrainttypes_statement(self, ctx: GromacsPTParser.Constrainttypes_statementContext):
        if ctx.constrainttypes(0):
            return
        self.constrainttypesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#constrainttypes.
    def enterConstrainttypes(self, ctx: GromacsPTParser.ConstrainttypesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#constrainttypes.
    def exitConstrainttypes(self, ctx: GromacsPTParser.ConstrainttypesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#nonbonded_params_statement.
    def enterNonbonded_params_statement(self, ctx: GromacsPTParser.Nonbonded_params_statementContext):  # pylint: disable=unused-argument
        self.nonbond_paramsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#nonbonded_params_statement.
    def exitNonbonded_params_statement(self, ctx: GromacsPTParser.Nonbonded_params_statementContext):
        if ctx.nonbonded_params(0):
            return
        self.nonbond_paramsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#nonbonded_params.
    def enterNonbonded_params(self, ctx: GromacsPTParser.Nonbonded_paramsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#nonbonded_params.
    def exitNonbonded_params(self, ctx: GromacsPTParser.Nonbonded_paramsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#atoms_statement.
    def enterAtoms_statement(self, ctx: GromacsPTParser.Atoms_statementContext):  # pylint: disable=unused-argument
        self.atomsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#atoms_statement.
    def exitAtoms_statement(self, ctx: GromacsPTParser.Atoms_statementContext):  # pylint: disable=unused-argument
        if ctx.atoms(0):
            return
        self.atomsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#atoms.
    def enterAtoms(self, ctx: GromacsPTParser.AtomsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#atoms.
    def exitAtoms(self, ctx: GromacsPTParser.AtomsContext):

        try:

            nr = int(str(ctx.Integer(0)))
            seqId = int(str(ctx.Integer(1)))
            # cgnr = int(str(ctx.Integer(2)))

            type = str(ctx.Simple_name(0))
            compId = str(ctx.Simple_name(1))
            atomId = str(ctx.Simple_name(2))

            atom = {'atom_number': nr,
                    'auth_seq_id': seqId,
                    'auth_comp_id': compId,
                    'auth_atom_id': atomId,
                    'atom_type': type}

            if atom not in self.__atoms:
                self.__atoms.append(atom)

        finally:
            self.numberSelection.clear()

    # Enter a parse tree produced by GromacsPTParser#bonds_statement.
    def enterBonds_statement(self, ctx: GromacsPTParser.Bonds_statementContext):  # pylint: disable=unused-argument
        self.bondsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#bonds_statement.
    def exitBonds_statement(self, ctx: GromacsPTParser.Bonds_statementContext):
        if ctx.bonds(0):
            return
        self.bondsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#bonds.
    def enterBonds(self, ctx: GromacsPTParser.BondsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#bonds.
    def exitBonds(self, ctx: GromacsPTParser.BondsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#pairs_statement.
    def enterPairs_statement(self, ctx: GromacsPTParser.Pairs_statementContext):  # pylint: disable=unused-argument
        self.pairsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#pairs_statement.
    def exitPairs_statement(self, ctx: GromacsPTParser.Pairs_statementContext):
        if ctx.pairs(0):
            return
        self.pairsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#pairs.
    def enterPairs(self, ctx: GromacsPTParser.PairsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#pairs.
    def exitPairs(self, ctx: GromacsPTParser.PairsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#pairs_nb_statement.
    def enterPairs_nb_statement(self, ctx: GromacsPTParser.Pairs_nb_statementContext):  # pylint: disable=unused-argument
        self.pairs_nbStatements += 1

    # Exit a parse tree produced by GromacsPTParser#pairs_nb_statement.
    def exitPairs_nb_statement(self, ctx: GromacsPTParser.Pairs_nb_statementContext):
        if ctx.pairs_nb(0):
            return
        self.pairs_nbStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#pairs_nb.
    def enterPairs_nb(self, ctx: GromacsPTParser.Pairs_nbContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#pairs_nb.
    def exitPairs_nb(self, ctx: GromacsPTParser.Pairs_nbContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#angles_statement.
    def enterAngles_statement(self, ctx: GromacsPTParser.Angles_statementContext):  # pylint: disable=unused-argument
        self.anglesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#angles_statement.
    def exitAngles_statement(self, ctx: GromacsPTParser.Angles_statementContext):
        if ctx.angles(0):
            return
        self.anglesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#angles.
    def enterAngles(self, ctx: GromacsPTParser.AnglesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#angles.
    def exitAngles(self, ctx: GromacsPTParser.AnglesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#dihedrals_statement.
    def enterDihedrals_statement(self, ctx: GromacsPTParser.Dihedrals_statementContext):  # pylint: disable=unused-argument
        self.dihedralsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#dihedrals_statement.
    def exitDihedrals_statement(self, ctx: GromacsPTParser.Dihedrals_statementContext):
        if ctx.dihedrals(0):
            return
        self.dihedralsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#dihedrals.
    def enterDihedrals(self, ctx: GromacsPTParser.DihedralsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#dihedrals.
    def exitDihedrals(self, ctx: GromacsPTParser.DihedralsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#exclusions_statement.
    def enterExclusions_statement(self, ctx: GromacsPTParser.Exclusions_statementContext):  # pylint: disable=unused-argument
        self.exclusionsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#exclusions_statement.
    def exitExclusions_statement(self, ctx: GromacsPTParser.Exclusions_statementContext):
        if ctx.exclusions(0):
            return
        self.exclusionsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#exclusions.
    def enterExclusions(self, ctx: GromacsPTParser.ExclusionsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#exclusions.
    def exitExclusions(self, ctx: GromacsPTParser.ExclusionsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#constraints_statement.
    def enterConstraints_statement(self, ctx: GromacsPTParser.Constraints_statementContext):  # pylint: disable=unused-argument
        self.constraintsStatements += 1

    # Exit a parse tree produced by GromacsPTParser#constraints_statement.
    def exitConstraints_statement(self, ctx: GromacsPTParser.Constraints_statementContext):
        if ctx.constraints(0):
            return
        self.constraintsStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#constraints.
    def enterConstraints(self, ctx: GromacsPTParser.ConstraintsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#constraints.
    def exitConstraints(self, ctx: GromacsPTParser.ConstraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#settles_statement.
    def enterSettles_statement(self, ctx: GromacsPTParser.Settles_statementContext):  # pylint: disable=unused-argument
        self.settlesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#settles_statement.
    def exitSettles_statement(self, ctx: GromacsPTParser.Settles_statementContext):
        if ctx.settles(0):
            return
        self.settlesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#settles.
    def enterSettles(self, ctx: GromacsPTParser.SettlesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#settles.
    def exitSettles(self, ctx: GromacsPTParser.SettlesContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#virtual_sites1_statement.
    def enterVirtual_sites1_statement(self, ctx: GromacsPTParser.Virtual_sites1_statementContext):  # pylint: disable=unused-argument
        self.virtual_sites1Statements += 1

    # Exit a parse tree produced by GromacsPTParser#virtual_sites1_statement.
    def exitVirtual_sites1_statement(self, ctx: GromacsPTParser.Virtual_sites1_statementContext):
        if ctx.virtual_sites1(0):
            return
        self.virtual_sites1Statements -= 1

    # Enter a parse tree produced by GromacsPTParser#virtual_sites1.
    def enterVirtual_sites1(self, ctx: GromacsPTParser.Virtual_sites1Context):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#virtual_sites1.
    def exitVirtual_sites1(self, ctx: GromacsPTParser.Virtual_sites1Context):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#virtual_sites2_statement.
    def enterVirtual_sites2_statement(self, ctx: GromacsPTParser.Virtual_sites2_statementContext):  # pylint: disable=unused-argument
        self.virtual_sites2Statements += 1

    # Exit a parse tree produced by GromacsPTParser#virtual_sites2_statement.
    def exitVirtual_sites2_statement(self, ctx: GromacsPTParser.Virtual_sites2_statementContext):
        if ctx.virtual_sites2(0):
            return
        self.virtual_sites2Statements -= 1

    # Enter a parse tree produced by GromacsPTParser#virtual_sites2.
    def enterVirtual_sites2(self, ctx: GromacsPTParser.Virtual_sites2Context):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#virtual_sites2.
    def exitVirtual_sites2(self, ctx: GromacsPTParser.Virtual_sites2Context):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#virtual_sites3_statement.
    def enterVirtual_sites3_statement(self, ctx: GromacsPTParser.Virtual_sites3_statementContext):  # pylint: disable=unused-argument
        self.virtual_sites3Statements += 1

    # Exit a parse tree produced by GromacsPTParser#virtual_sites3_statement.
    def exitVirtual_sites3_statement(self, ctx: GromacsPTParser.Virtual_sites3_statementContext):
        if ctx.virtual_sites3(0):
            return
        self.virtual_sites3Statements -= 1

    # Enter a parse tree produced by GromacsPTParser#virtual_sites3.
    def enterVirtual_sites3(self, ctx: GromacsPTParser.Virtual_sites3Context):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#virtual_sites3.
    def exitVirtual_sites3(self, ctx: GromacsPTParser.Virtual_sites3Context):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#virtual_sites4_statement.
    def enterVirtual_sites4_statement(self, ctx: GromacsPTParser.Virtual_sites4_statementContext):  # pylint: disable=unused-argument
        self.virtual_sites4Statements += 1

    # Exit a parse tree produced by GromacsPTParser#virtual_sites4_statement.
    def exitVirtual_sites4_statement(self, ctx: GromacsPTParser.Virtual_sites4_statementContext):
        if ctx.virtual_sites4(0):
            return
        self.virtual_sites4Statements -= 1

    # Enter a parse tree produced by GromacsPTParser#virtual_sites4.
    def enterVirtual_sites4(self, ctx: GromacsPTParser.Virtual_sites4Context):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#virtual_sites4.
    def exitVirtual_sites4(self, ctx: GromacsPTParser.Virtual_sites4Context):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#virtual_sitesn_statement.
    def enterVirtual_sitesn_statement(self, ctx: GromacsPTParser.Virtual_sitesn_statementContext):  # pylint: disable=unused-argument
        self.virtual_sitesnStatements += 1

    # Exit a parse tree produced by GromacsPTParser#virtual_sitesn_statement.
    def exitVirtual_sitesn_statement(self, ctx: GromacsPTParser.Virtual_sitesn_statementContext):
        if ctx.virtual_sitesn(0):
            return
        self.virtual_sitesnStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#virtual_sitesn.
    def enterVirtual_sitesn(self, ctx: GromacsPTParser.Virtual_sitesnContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#virtual_sitesn.
    def exitVirtual_sitesn(self, ctx: GromacsPTParser.Virtual_sitesnContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#system_statement.
    def enterSystem_statement(self, ctx: GromacsPTParser.System_statementContext):  # pylint: disable=unused-argument
        self.systemStatements += 1

    # Exit a parse tree produced by GromacsPTParser#system_statement.
    def exitSystem_statement(self, ctx: GromacsPTParser.System_statementContext):
        if ctx.Simple_name_A(0):
            title = []
            i = 0
            while ctx.Simple_name_A(i):
                title.append(str(ctx.Simple_name_A(i)))
                i += 1

            self.__system = ' '.join(title)
            return
        self.systemStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#molecules_statement.
    def enterMolecules_statement(self, ctx: GromacsPTParser.Molecules_statementContext):  # pylint: disable=unused-argument
        self.moleculesStatements += 1

    # Exit a parse tree produced by GromacsPTParser#molecules_statement.
    def exitMolecules_statement(self, ctx: GromacsPTParser.Molecules_statementContext):
        if ctx.molecules(0):
            return
        self.moleculesStatements -= 1

    # Enter a parse tree produced by GromacsPTParser#molecules.
    def enterMolecules(self, ctx: GromacsPTParser.MoleculesContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#molecules.
    def exitMolecules(self, ctx: GromacsPTParser.MoleculesContext):
        name = str(ctx.Simple_name())
        number = int(str(ctx.Integer()))
        if number > 0:
            self.__molecules.append({'molecule_name': name, 'number_of_copies': number})

    # Enter a parse tree produced by GromacsPTParser#number.
    def enterNumber(self, ctx: GromacsPTParser.NumberContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#number.
    def exitNumber(self, ctx: GromacsPTParser.NumberContext):
        """ not used the 'number' in the '[ atoms ]' statement so that pass through for performance
        if ctx.Real():
            self.numberSelection.append(float(str(ctx.Real())))

        elif ctx.Integer():
            self.numberSelection.append(float(str(ctx.Integer())))

        else:
            self.numberSelection.append(None)
        """

    # Enter a parse tree produced by GromacsPTParser#position_restraints.
    def enterPosition_restraints(self, ctx: GromacsPTParser.Position_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#position_restraints.
    def exitPosition_restraints(self, ctx: GromacsPTParser.Position_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by GromacsPTParser#position_restraint.
    def enterPosition_restraint(self, ctx: GromacsPTParser.Position_restraintContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by GromacsPTParser#position_restraint.
    def exitPosition_restraint(self, ctx: GromacsPTParser.Position_restraintContext):  # pylint: disable=unused-argument
        pass

    def getContentSubtype(self):
        """ Return content subtype of GROMACS parameter/topology file.
        """

        contentSubtype = {'default': self.defaultStatements,
                          'moleculetype': self.moleculetypeStatements,
                          'atomtypes': self.atomtypesStatements,
                          'pairtypes': self.pairtypesStatements,
                          'bondtypes': self.bondtypesStatements,
                          'angletypes': self.angletypesStatements,
                          'dihedraltypes': self.dihedraltypesStatements,
                          'constrainttypes': self.constrainttypesStatements,
                          'nonbond_params': self.nonbond_paramsStatements,
                          'atoms': self.atomsStatements,
                          'bonds': self.bondsStatements,
                          'pairs': self.pairsStatements,
                          'pairs_nb': self.pairs_nbStatements,
                          'angles': self.anglesStatements,
                          'dihedrals': self.dihedralsStatements,
                          'exclusions': self.exclusionsStatements,
                          'constraints': self.constraintsStatements,
                          'settles': self.settlesStatements,
                          'virtual_sites1': self.virtual_sites1Statements,
                          'virtual_sites2': self.virtual_sites2Statements,
                          'virtual_sites3': self.virtual_sites3Statements,
                          'virtual_sites4': self.virtual_sites4Statements,
                          'virtual_sitesn': self.virtual_sitesnStatements,
                          'system': self.systemStatements,
                          'molecules': self.moleculesStatements
                          }

        return {k: 1 for k, v in contentSubtype.items() if v > 0}

    def getSystem(self):
        """ Return system name of GROMACS parameter/topology file.
        """
        return self.__system

    def getMolecules(self):
        """ Return list of molecules and its number of copies in GROMACS parameter/topology file.
        """
        return self.__molecules

    def getAtomNumberDict(self):
        """ Return GROMACS atomic number dictionary.
        """
        return self.__atomNumberDict

    def getPolymerSequence(self):
        """ Return polymer sequence of GROMACS parameter/topology file.
        """
        return self.__polySeqPrmTop

    def getSequenceAlignment(self):
        """ Return sequence alignment between coordinates and GROMACS parameter/topology.
        """
        return self.__seqAlign

    def getChainAssignment(self):
        """ Return chain assignment between coordinates and GROMACS parameter/topology.
        """
        return self.__chainAssign


# del GromacsPTParser
