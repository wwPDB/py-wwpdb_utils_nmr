##
# File: RosettaMRParserListener.py
# Date: 04-Mar-2022
#
# Updates:
# Generated from RosettaMRParser.g4 by ANTLR 4.9
""" ParserLister class for ROSETTA MR files.
    @author: Masashi Yokochi
"""
import sys
import copy
import numpy as np

from antlr4 import ParseTreeListener

try:
    from wwpdb.utils.nmr.mr.RosettaMRParser import RosettaMRParser
    from wwpdb.utils.nmr.mr.ParserListenerUtil import (checkCoordinates,
                                                       DIST_RESTRAINT_RANGE,
                                                       DIST_RESTRAINT_ERROR)

    from wwpdb.utils.nmr.ChemCompUtil import ChemCompUtil
    from wwpdb.utils.nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from wwpdb.utils.nmr.NEFTranslator.NEFTranslator import NEFTranslator
except ImportError:
    from nmr.mr.RosettaMRParser import RosettaMRParser
    from nmr.mr.ParserListenerUtil import (checkCoordinates,
                                           DIST_RESTRAINT_RANGE,
                                           DIST_RESTRAINT_ERROR)

    from nmr.ChemCompUtil import ChemCompUtil
    from nmr.BMRBChemShiftStat import BMRBChemShiftStat
    from nmr.NEFTranslator.NEFTranslator import NEFTranslator


DIST_RANGE_MIN = DIST_RESTRAINT_RANGE['min_inclusive']
DIST_RANGE_MAX = DIST_RESTRAINT_RANGE['max_inclusive']

DIST_ERROR_MIN = DIST_RESTRAINT_ERROR['min_exclusive']
DIST_ERROR_MAX = DIST_RESTRAINT_ERROR['max_exclusive']


# This class defines a complete listener for a parse tree produced by RosettaMRParser.
class RosettaMRParserListener(ParseTreeListener):

    __verbose = None
    __lfh = None

    distRestraints = 0      # ROSETTA: Distance restraints
    angRestraints = 0       # ROSETTA: Angle restraints
    dihedRestraints = 0     # ROSETTA: Dihedral angle restraints
    rdcRestraints = 0       # ROSETTA: Residual dipolar coupling restraints
    geoRestraints = 0       # ROSETTA: Coodinate geometry restraints

    # CCD accessing utility
    __ccU = None

    # BMRB chemical shift statistics
    __csStat = None

    # NEFTranslator
    __nefT = None

    # CIF reader
    __cR = None
    __hasCoord = False

    # data item name for model ID in 'atom_site' category
    __modelNumName = None

    # data item names for auth_asym_id, auth_seq_id, auth_atom_id in 'atom_site' category
    __authAsymId = None
    __authSeqId = None
    __authAtomId = None
    __altAuthAtomId = None

    # polymer sequences in the coordinate file generated by NmrDpUtility.__extractCoordPolymerSequence()
    __hasPolySeq = False
    __polySeq = None
    __coordAtomSite = None
    __coordUnobsRes = None

    # current restraint subtype
    __cur_subtype = None

    stackFuncs = None  # stack of function

    # collection of atom selection
    atomSelectionSet = None

    warningMessage = ''

    def __init__(self, verbose=True, log=sys.stdout, cR=None,
                 polySeq=None, coordAtomSite=None, coordUnobsRes=None,
                 ccU=None, csStat=None, nefT=None):
        self.__verbose = verbose
        self.__lfh = log
        self.__cR = cR
        self.__hasCoord = cR is not None

        if self.__hasCoord:
            dict = checkCoordinates(verbose, log, cR, polySeq, coordAtomSite, coordUnobsRes)
            self.__modelNumName = dict['model_num_name']
            self.__authAsymId = dict['auth_asym_id']
            self.__authSeqId = dict['auth_seq_id']
            self.__authAtomId = dict['auth_atom_id']
            self.__altAuthAtomId = dict['alt_auth_atom_id']
            self.__polySeq = dict['polymer_sequence']
            self.__coordAtomSite = dict['coord_atom_site']
            self.__coordUnobsRes = dict['coord_unobs_res']

        self.__hasPolySeq = self.__polySeq is not None and len(self.__polySeq) > 0

        # CCD accessing utility
        self.__ccU = ChemCompUtil(verbose, log) if ccU is None else ccU

        # BMRB chemical shift statistics
        self.__csStat = BMRBChemShiftStat(verbose, log, self.__ccU) if csStat is None else csStat

        # NEFTranslator
        self.__nefT = NEFTranslator(verbose, log, self.__ccU, self.__csStat) if nefT is None else nefT

    # Enter a parse tree produced by RosettaMRParser#rosetta_mr.
    def enterRosetta_mr(self, ctx: RosettaMRParser.Rosetta_mrContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by RosettaMRParser#rosetta_mr.
    def exitRosetta_mr(self, ctx: RosettaMRParser.Rosetta_mrContext):  # pylint: disable=unused-argument
        if len(self.warningMessage) == 0:
            self.warningMessage = None
        else:
            self.warningMessage = self.warningMessage[0:-1]
            self.warningMessage = '\n'.join(set(self.warningMessage.split('\n')))

    # Enter a parse tree produced by RosettaMRParser#atom_pair_restraints.
    def enterAtom_pair_restraints(self, ctx: RosettaMRParser.Atom_pair_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dist'

    # Exit a parse tree produced by RosettaMRParser#atom_pair_restraints.
    def exitAtom_pair_restraints(self, ctx: RosettaMRParser.Atom_pair_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#atom_pair_restraint.
    def enterAtom_pair_restraint(self, ctx: RosettaMRParser.Atom_pair_restraintContext):  # pylint: disable=unused-argument
        self.distRestraints += 1

        self.stackFuncs = []
        self.atomSelectionSet = []

    # Exit a parse tree produced by RosettaMRParser#atom_pair_restraint.
    def exitAtom_pair_restraint(self, ctx: RosettaMRParser.Atom_pair_restraintContext):
        if not self.__hasPolySeq:
            return

        seqId1 = int(str(ctx.Integer(0)))
        atomId1 = str(ctx.Simple_name(0)).upper()
        seqId2 = int(str(ctx.Integer(1)))
        atomId2 = str(ctx.Simple_name(1)).upper()

        target_value = None
        lower_limit = None
        upper_limit = None
        lower_linear_limit = None
        upper_linear_limit = None

        firstFunc = None
        srcFunc = None

        level = 0
        while self.stackFuncs:
            func = self.stackFuncs.pop()
            if func is not None:
                if firstFunc is None:
                    firstFunc = copy.copy(func)
                if func['name'] in ('SCALARWEIGHTEDFUNC', 'SUMFUNC'):
                    continue
                if 'func_types' in firstFunc:
                    firstFunc['func_types'].append(func['name'])
                if srcFunc is None:
                    srcFunc = copy.copy(func)
                if 'target_value' in func:
                    target_value = func['target_value']
                    del srcFunc['target_value']
                if 'lower_limit' in func:
                    lower_limit = func['lower_limit']
                    del srcFunc['lower_limit']
                if 'upper_limit' in func:
                    upper_limit = func['upper_limit']
                    del srcFunc['upper_limit']
                if 'lower_linear_limit' in func:
                    lower_linear_limit = func['lower_linear_limit']
                    del srcFunc['lower_linear_limit']
                if 'upper_linear_limit' in func:
                    upper_linear_limit = func['upper_linear_limit']
                    del srcFunc['upper_linear_limit']
                level += 1

        if srcFunc is None:  # errors are already caught
            return

        if level > 1:
            self.warningMessage += f"[Complex data] {self.__getCurrentRestraint()}"\
                f"Too complex constraint function {firstFunc} can not be converted to NEF/NMR-STAR data.\n"
            return

        if target_value is None and lower_limit is None and upper_limit is None\
           and lower_linear_limit is None and upper_linear_limit is None:
            self.warningMessage += f"[Unsupported data] {self.__getCurrentRestraint()}"\
                f"The constraint function {srcFunc} can not be converted to NEF/NMR-STAR data.\n"
            return

        validRange = True
        dstFunc = {}

        if target_value is not None:
            if DIST_ERROR_MIN < target_value < DIST_ERROR_MAX:
                dstFunc['target_value'] = f"{target_value:.3}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the target value='{target_value}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if lower_limit is not None:
            if DIST_ERROR_MIN < lower_limit < DIST_ERROR_MAX:
                dstFunc['lower_limit'] = f"{lower_limit:.3}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the lower limit value='{lower_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if upper_limit is not None:
            if DIST_ERROR_MIN < upper_limit < DIST_ERROR_MAX:
                dstFunc['upper_limit'] = f"{upper_limit:.3}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the upper limit value='{upper_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if lower_linear_limit is not None:
            if DIST_ERROR_MIN < lower_linear_limit < DIST_ERROR_MAX:
                dstFunc['lower_linear_limit'] = f"{lower_linear_limit:.3}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the lower linear limit value='{lower_linear_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if upper_linear_limit is not None:
            if DIST_ERROR_MIN < upper_linear_limit < DIST_ERROR_MAX:
                dstFunc['upper_linear_limit'] = f"{upper_linear_limit:.3}"
            else:
                validRange = False
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the upper linear limit value='{upper_linear_limit}' must be within range {DIST_RESTRAINT_ERROR}.\n"

        if not validRange:
            return

        if target_value is not None:
            if DIST_RANGE_MIN <= target_value <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the target value='{target_value}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        if lower_limit is not None:
            if DIST_RANGE_MIN <= lower_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the lower limit value='{lower_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        if upper_limit is not None:
            if DIST_RANGE_MIN <= upper_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the upper limit value='{upper_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        if lower_linear_limit is not None:
            if DIST_RANGE_MIN <= lower_linear_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the lower linear limit value='{lower_linear_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        if upper_linear_limit is not None:
            if DIST_RANGE_MIN <= upper_linear_limit <= DIST_RANGE_MAX:
                pass
            else:
                self.warningMessage += f"[Range value error] {self.__getCurrentRestraint()}"\
                    f"{srcFunc}, the upper linear limit value='{upper_linear_limit}' should be within range {DIST_RESTRAINT_RANGE}.\n"

        chainId1 = []
        chainId2 = []

        for ps in self.__polySeq:
            chainId = ps['chain_id']
            if seqId1 in ps['seq_id']:
                compId = ps['comp_id'][ps['seq_id'].index(seqId1)]
                if len(self.__nefT.get_valid_star_atom(compId, atomId1)[0]) > 0:
                    chainId1.append((chainId, compId))
            if seqId2 in ps['seq_id']:
                compId = ps['comp_id'][ps['seq_id'].index(seqId2)]
                if len(self.__nefT.get_valid_star_atom(compId, atomId2)[0]) > 0:
                    chainId2.append((chainId, compId))

        if len(chainId1) == 0 or len(chainId2) == 0:
            if len(chainId1) == 0:
                self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                    f"{seqId1}:{atomId1} is not present in the coordinate.\n"
                chainId1 = [self.__polySeq[0]['chain_id']]  # mitigation
            if len(chainId2) == 0:
                self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                    f"{seqId2}:{atomId2} is not present in the coordinate.\n"
                chainId2 = [self.__polySeq[0]['chain_id']]  # mitigation

        try:

            atomSelection = []

            for chainId, compId in chainId1:
                seqKey = (chainId, seqId1)
                coordAtomSite = None if not self.__hasCoord or seqKey not in self.__coordAtomSite else self.__coordAtomSite[seqKey]
                _atomId1 = self.__nefT.get_valid_star_atom(compId, atomId1)[0]
                if len(_atomId1) == 0:
                    self.warningMessage += f"[Invalid atom nomenclature] {self.__getCurrentRestraint()}"\
                        f"{seqId1}:{compId}:{atomId1} is invalid atom nomenclature.\n"
                for atomId in _atomId1:
                    atomSelection.append({'chain_id': chainId, 'seq_id': seqId1, 'comp_id': compId, 'atom_id': atomId})

                    if self.__hasCoord:
                        if coordAtomSite is not None and (atomId in coordAtomSite['atom_id']
                                                          or ('alt_atom_id' in coordAtomSite and atomId in coordAtomSite['alt_atom_id'])):
                            pass
                        elif self.__ccU.updateChemCompDict(compId):
                            cca = next((cca for cca in self.__ccU.lastAtomList if cca[self.__ccU.ccaAtomId] == atomId), None)
                            if cca is not None and seqKey not in self.__coordUnobsRes:
                                self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                                    f"{chainId}:{seqId1}:{compId}:{atomId} is not present in the coordinate.\n"

            self.atomSelectionSet.append(atomSelection)

            atomSelection = []

            for chainId, compId in chainId2:
                seqKey = (chainId, seqId2)
                coordAtomSite = None if not self.__hasCoord or seqKey not in self.__coordAtomSite else self.__coordAtomSite[seqKey]
                _atomId2 = self.__nefT.get_valid_star_atom(compId, atomId2)[0]
                if len(_atomId2) == 0:
                    self.warningMessage += f"[Invalid atom nomenclature] {self.__getCurrentRestraint()}"\
                        f"{seqId2}:{compId}:{atomId2} is invalid atom nomenclature.\n"
                for atomId in _atomId2:
                    atomSelection.append({'chain_id': chainId, 'seq_id': seqId2, 'comp_id': compId, 'atom_id': atomId})

                    if self.__hasCoord:
                        if coordAtomSite is not None and (atomId in coordAtomSite['atom_id']
                                                          or ('auth_atom_id' in coordAtomSite and atomId in coordAtomSite['auth_atom_id'])):
                            pass
                        elif self.__ccU.updateChemCompDict(compId):
                            cca = next((cca for cca in self.__ccU.lastAtomList if cca[self.__ccU.ccaAtomId] == atomId), None)
                            if cca is not None and seqKey not in self.__coordUnobsRes:
                                self.warningMessage += f"[Atom not found] {self.__getCurrentRestraint()}"\
                                    f"{chainId}:{seqId2}:{compId}:{atomId} is not present in the coordinate.\n"

            self.atomSelectionSet.append(atomSelection)

        except Exception as e:
            if self.__verbose:
                self.__lfh.write(f"+RosettaMRParserListener.exitAtom_pair_restraint() ++ Error  - {str(e)}\n")

        for atom_1 in self.atomSelectionSet[0]:
            for atom_2 in self.atomSelectionSet[1]:
                print(f"subtype={self.__cur_subtype} id={self.distRestraints} "
                      f"atom_1={atom_1} atom_2={atom_2} {dstFunc}")

    # Enter a parse tree produced by RosettaMRParser#angle_restraints.
    def enterAngle_restraints(self, ctx: RosettaMRParser.Angle_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'ang'

    # Exit a parse tree produced by RosettaMRParser#angle_restraints.
    def exitAngle_restraints(self, ctx: RosettaMRParser.Angle_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#angle_restraint.
    def enterAngle_restraint(self, ctx: RosettaMRParser.Angle_restraintContext):  # pylint: disable=unused-argument
        self.angRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#angle_restraint.
    def exitAngle_restraint(self, ctx: RosettaMRParser.Angle_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#dihedral_restraints.
    def enterDihedral_restraints(self, ctx: RosettaMRParser.Dihedral_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dihed'

    # Exit a parse tree produced by RosettaMRParser#dihedral_restraints.
    def exitDihedral_restraints(self, ctx: RosettaMRParser.Dihedral_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#dihedral_restraint.
    def enterDihedral_restraint(self, ctx: RosettaMRParser.Dihedral_restraintContext):  # pylint: disable=unused-argument
        self.dihedRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#dihedral_restraint.
    def exitDihedral_restraint(self, ctx: RosettaMRParser.Dihedral_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#dihedral_pair_restraints.
    def enterDihedral_pair_restraints(self, ctx: RosettaMRParser.Dihedral_pair_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dihed'

    # Exit a parse tree produced by RosettaMRParser#dihedral_pair_restraints.
    def exitDihedral_pair_restraints(self, ctx: RosettaMRParser.Dihedral_pair_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#dihedral_pair_restraint.
    def enterDihedral_pair_restraint(self, ctx: RosettaMRParser.Dihedral_pair_restraintContext):  # pylint: disable=unused-argument
        self.dihedRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#dihedral_pair_restraint.
    def exitDihedral_pair_restraint(self, ctx: RosettaMRParser.Dihedral_pair_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#coordinate_restraints.
    def enterCoordinate_restraints(self, ctx: RosettaMRParser.Coordinate_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#coordinate_restraints.
    def exitCoordinate_restraints(self, ctx: RosettaMRParser.Coordinate_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#coordinate_restraint.
    def enterCoordinate_restraint(self, ctx: RosettaMRParser.Coordinate_restraintContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#coordinate_restraint.
    def exitCoordinate_restraint(self, ctx: RosettaMRParser.Coordinate_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#local_coordinate_restraints.
    def enterLocal_coordinate_restraints(self, ctx: RosettaMRParser.Local_coordinate_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#local_coordinate_restraints.
    def exitLocal_coordinate_restraints(self, ctx: RosettaMRParser.Local_coordinate_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#local_coordinate_restraint.
    def enterLocal_coordinate_restraint(self, ctx: RosettaMRParser.Local_coordinate_restraintContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#local_coordinate_restraint.
    def exitLocal_coordinate_restraint(self, ctx: RosettaMRParser.Local_coordinate_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#site_restraints.
    def enterSite_restraints(self, ctx: RosettaMRParser.Site_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#site_restraints.
    def exitSite_restraints(self, ctx: RosettaMRParser.Site_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#site_restraint.
    def enterSite_restraint(self, ctx: RosettaMRParser.Site_restraintContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#site_restraint.
    def exitSite_restraint(self, ctx: RosettaMRParser.Site_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#site_residues_restraints.
    def enterSite_residues_restraints(self, ctx: RosettaMRParser.Site_residues_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#site_residues_restraints.
    def exitSite_residues_restraints(self, ctx: RosettaMRParser.Site_residues_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#site_residues_restraint.
    def enterSite_residues_restraint(self, ctx: RosettaMRParser.Site_residues_restraintContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#site_residues_restraint.
    def exitSite_residues_restraint(self, ctx: RosettaMRParser.Site_residues_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#min_residue_atomic_distance_restraints.
    def enterMin_residue_atomic_distance_restraints(self, ctx: RosettaMRParser.Min_residue_atomic_distance_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#min_residue_atomic_distance_restraints.
    def exitMin_residue_atomic_distance_restraints(self, ctx: RosettaMRParser.Min_residue_atomic_distance_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#min_residue_atomic_distance_restraint.
    def enterMin_residue_atomic_distance_restraint(self, ctx: RosettaMRParser.Min_residue_atomic_distance_restraintContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#min_residue_atomic_distance_restraint.
    def exitMin_residue_atomic_distance_restraint(self, ctx: RosettaMRParser.Min_residue_atomic_distance_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#big_bin_restraints.
    def enterBig_bin_restraints(self, ctx: RosettaMRParser.Big_bin_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'dihed'

    # Exit a parse tree produced by RosettaMRParser#big_bin_restraints.
    def exitBig_bin_restraints(self, ctx: RosettaMRParser.Big_bin_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#big_bin_restraint.
    def enterBig_bin_restraint(self, ctx: RosettaMRParser.Big_bin_restraintContext):  # pylint: disable=unused-argument
        self.dihedRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#big_bin_restraint.
    def exitBig_bin_restraint(self, ctx: RosettaMRParser.Big_bin_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#nested_restraints.
    def enterNested_restraints(self, ctx: RosettaMRParser.Nested_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by RosettaMRParser#nested_restraints.
    def exitNested_restraints(self, ctx: RosettaMRParser.Nested_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#nested_restraint.
    def enterNested_restraint(self, ctx: RosettaMRParser.Nested_restraintContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by RosettaMRParser#nested_restraint.
    def exitNested_restraint(self, ctx: RosettaMRParser.Nested_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#any_restraint.
    def enterAny_restraint(self, ctx: RosettaMRParser.Any_restraintContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by RosettaMRParser#any_restraint.
    def exitAny_restraint(self, ctx: RosettaMRParser.Any_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#func_type_def.
    def enterFunc_type_def(self, ctx: RosettaMRParser.Func_type_defContext):  # pylint: disable=unused-argument
        pass

    # Exit a parse tree produced by RosettaMRParser#func_type_def.
    def exitFunc_type_def(self, ctx: RosettaMRParser.Func_type_defContext):
        """
        (CIRCULARHARMONIC | HARMONIC | SIGMOID | SQUARE_WELL) Float Float |
        BOUNDED Float Float Float Float? Simple_name? |
        PERIODICBOUNDED Float Float Float Float Float? Simple_name? |
        OFFSETPERIODICBOUNDED Float Float Float Float Float Float? Simple_name? |
        (AMBERPERIODIC | CHARMMPERIODIC | FLAT_HARMONIC | TOPOUT) Float Float Float |
        (CIRCULARSIGMOIDAL | LINEAR_PENALTY) Float Float Float Float |
        CIRCULARSPLINE Float+ |
        GAUSSIANFUNC Float Float Simple_name (WEIGHT Float)? |
        SOGFUNC Integer (Float Float Float)+ |
        (MIXTUREFUNC | KARPLUS | SOEDINGFUNC) Float Float Float Float Float Float |
        CONSTANTFUNC Float |
        IDENTITY |
        SCALARWEIGHTEDFUNC Float func_type_def |
        SUMFUNC Integer func_type_def+ |
        SPLINE Simple_name (Float Float Float | NONE Float Float Float (Simple_name Float*)+) // histogram_file_path can not be evaluated
        FADE Float Float Float Float Float? |
        SQUARE_WELL2 Float Float Float DEGREES? |
        ETABLE Float Float Float* |
        USOG Integer (Float Float Float Float)+ |
        SOG Integer (Float Float Float Float Float Float)+;
        """

        func = {}
        valid = True

        if ctx.CIRCULARHARMONIC() or ctx.HARMONIC() or ctx.SIGMOID() or ctx.SQUARE_WELL():
            x0 = float(str(ctx.Float(0)))

            func['x0'] = x0

            if ctx.CIRCULARHARMONIC():  # x0 sd
                funcType = 'CIRCULARHARMONIC'

                sd = float(str(ctx.Float(1)))

                func['sd'] = sd

                if sd <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

                func['target_value'] = x0
                func['lower_limit'] = x0 - sd
                func['upper_limit'] = x0 + sd

            elif ctx.HARMONIC():  # x0 sd
                funcType = 'HARMONIC'

                sd = float(str(ctx.Float(1)))

                func['sd'] = sd

                if sd <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

                func['target_value'] = x0
                func['lower_limit'] = x0 - sd
                func['upper_limit'] = x0 + sd

            elif ctx.SIGMOID():  # x0 m
                funcType = 'SIGMOID'

                m = float(str(ctx.Float(1)))

                func['m'] = m

                if m > 0.0:
                    func['upper_linear_limit'] = x0
                else:
                    func['lower_lienar_limit'] = x0

            else:  # x0 depth
                funcType = 'SQUARE_WELL'

                depth = float(str(ctx.Float(1)))

                func['depth'] = depth

                if depth > 0.0:
                    func['lower_linear_limit'] = x0
                elif depth < 0.0:
                    func['upper_linear_limit'] = x0

            func['name'] = funcType

        elif ctx.BOUNDED():  # lb ub sd rswitch tag
            funcType = 'BOUNDED'
            lb = float(str(ctx.Float(0)))
            ub = float(str(ctx.Float(1)))
            sd = float(str(ctx.Float(2)))
            rswitch = 0.5

            func['name'] = funcType
            func['lb'] = lb
            func['ub'] = ub
            func['sd'] = sd

            if lb > ub:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} lower boundary 'lb={lb}' must be less than or equal to upper boundary 'ub={ub}'.\n"
            if sd <= 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

            if ctx.Float(3):
                rswitch = float(str(ctx.Float(3)))

                func['rswitch'] = rswitch

                if rswitch < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} additional value for switching from the upper limit to the upper linear limit 'rswitch={rswitch}' must not be a negative value.\n"

            if ctx.Simple_name(0):
                func['tag'] = str(ctx.Simple_name(0))

            func['lower_limit'] = lb
            func['upper_limit'] = ub
            func['upper_linear_limit'] = ub + rswitch
            func['lower_linear_limit'] = lb - rswitch

        elif ctx.PERIODICBOUNDED():  # period lb ub sd rswitch tag
            funcType = 'PERIODICBOUNDED'

            period = float(str(ctx.Float(0)))
            lb = float(str(ctx.Float(1)))
            ub = float(str(ctx.Float(2)))
            sd = float(str(ctx.Float(3)))
            rswitch = 0.5

            func['name'] = funcType
            func['period'] = period
            func['lb'] = lb
            func['ub'] = ub
            func['sd'] = sd

            if period < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'period={period}' must not be a negative value.\n"
            if lb > ub:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} lower boundary 'lb={lb}' must be less than or equal to upper boundary 'ub={ub}'.\n"
            if sd <= 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

            if ctx.Float(4):
                rswitch = float(str(ctx.Float(4)))

                func['rswitch'] = rswitch

                if rswitch < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} additional value for switching from the upper limit to the upper linear limit 'rswitch={rswitch}' must not be a negative value.\n"

            if ctx.Simple_name(0):
                func['tag'] = str(ctx.Simple_name(0))

            func['lower_limit'] = lb
            func['upper_limit'] = ub
            func['upper_linear_limit'] = ub + rswitch
            func['lower_linear_limit'] = lb - rswitch

        elif ctx.OFFSETPERIODICBOUNDED():  # offset period lb ub sd rswitch tag
            funcType = 'OFFSETPERIODICBOUNDED'

            offset = float(str(ctx.Float(0)))
            period = float(str(ctx.Float(1)))
            lb = float(str(ctx.Float(2)))
            ub = float(str(ctx.Float(3)))
            sd = float(str(ctx.Float(4)))
            rswitch = 0.5

            func['name'] = funcType
            func['offset'] = offset
            func['period'] = period
            func['lb'] = lb
            func['ub'] = ub
            func['sd'] = sd

            if period < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'period={period}' must not be a negative value.\n"
            if lb > ub:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} lower boundary 'lb={lb}' must be less than or equal to upper boundary 'ub={ub}'.\n"
            if sd <= 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

            if ctx.Float(5):
                rswitch = float(str(ctx.Float(5)))

                func['rswitch'] = rswitch

                if rswitch < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} additional value for switching from the upper limit to the upper linear limit 'rswitch={rswitch}' must not be a negative value.\n"

            if ctx.Simple_name(0):
                func['tag'] = str(ctx.Simple_name(0))

            func['lower_limit'] = lb + offset
            func['upper_limit'] = ub + offset
            func['upper_linear_limit'] = ub + rswitch + offset
            func['lower_linear_limit'] = lb - rswitch + offset

        elif ctx.AMBERPERIODIC() or ctx.CHARMMPERIODIC():  # x0 n_period k
            funcType = 'AMBERPERIODIC' if ctx.AMBERPERIODIC() else 'CHARMMPERIODIC'
            x0 = float(str(ctx.Float(0)))
            n_period = float(str(ctx.Float(1)))
            k = float(str(ctx.Float(2)))

            func['name'] = funcType
            func['x0'] = x0
            func['n_period'] = n_period
            func['k'] = k

            if period < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} periodicity 'n_period={n_period}' must not be a negative value.\n"

        elif ctx.FLAT_HARMONIC() or ctx.TOPOUT():
            funcType = 'FLAT_HARMONIC' if ctx.FLAT_HARMONIC() else 'TOPOUT'

            if ctx.FLAT_HARMONIC():  # x0 sd tol
                x0 = float(str(ctx.Float(0)))
                sd = float(str(ctx.Float(1)))
                tol = float(str(ctx.Float(2)))

                func['x0'] = x0
                func['sd'] = sd
                func['tol'] = tol

                if sd <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"
                if tol < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} tolerance 'tol={tol}' must not be a negative value.\n"

                func['target_value'] = x0
                func['lower_limit'] = x0 - tol - sd
                func['upper_limit'] = x0 + tol + sd

            else:  # weight x0 limit
                weight = float(str(ctx.Float(0)))
                x0 = float(str(ctx.Float(1)))
                limit = float(str(ctx.Float(2)))

                func['weight'] = weight
                func['x0'] = x0
                func['limit'] = limit

                if weight < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} 'weight={weight}' must not be a negative value.\n"
                if limit <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} 'limit={limit}' must be a positive value.\n"

                func['target_value'] = x0
                func['lower_limit'] = x0 - limit
                func['upper_limit'] = x0 + limit

            func['name'] = funcType

        elif ctx.CIRCULARSIGMOIDAL() or ctx.LINEAR_PENALTY():
            funcType = 'CIRCULARSIGMOIDAL' if ctx.CIRCULARSIGMOIDAL() else 'LINEAR_PENALTY'

            if ctx.CIRCULARSIGMOIDAL():  # xC m o1 o2
                xC = float(str(ctx.Float(0)))
                m = float(str(ctx.Float(1)))
                o1 = float(str(ctx.Float(2)))
                o2 = float(str(ctx.Float(3)))

                func['xC'] = xC
                func['m'] = m
                func['o1'] = o1
                func['o2'] = o2

                if m < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} periodicity 'm={m}' must not be a negative value.\n"

            else:  # x0 depth width slope
                x0 = float(str(ctx.Float(0)))
                depth = float(str(ctx.Float(1)))
                width = float(str(ctx.Float(2)))
                slope = float(str(ctx.Float(3)))

                func['x0'] = x0
                func['depth'] = depth
                func['width'] = width
                func['slope'] = slope

                if width < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} 'width={width}' must not be a negative value.\n"
                if slope < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} 'slope={slope}' must not be a negative value.\n"

                func['lower_linear_limit'] = x0 - width
                func['upper_linear_limit'] = x0 + width

            func['name'] = funcType

        elif ctx.CIRCULARSPLINE():  # weight [36 energy values]
            funcType = 'CIRCULARSPLINE'
            weight = float(str(ctx.Float(0)))

            func['name'] = funcType
            func['weight'] = weight

            if weight < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'weight={weight}' must not be a negative value.\n"

            if ctx.Float(36):
                func['energy'] = []
                for i in range(36):
                    func['energy'].append(float(str(ctx.Float(i + 1))))
            else:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires consecutive 36 energy values, following the first weight value.\n"

        elif ctx.GAUSSIANFUNC():  # mean sd tag WEIGHT weight
            funcType = 'GAUSSIANFUNC'
            mean = float(str(ctx.Float(0)))
            sd = float(str(ctx.Float(1)))

            func['name'] = funcType
            func['mean'] = mean
            func['sd'] = sd
            func['tag'] = str(ctx.Simple_name(0))

            if sd <= 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

            if ctx.WEIGHT():
                weight = float(str(ctx.Float(2)))

                func['weight'] = weight

                if weight < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} 'weight={weight}' must not be a negative value.\n"

            func['target_value'] = mean
            func['lower_limit'] = mean - sd
            func['upper_limit'] = mean + sd

        elif ctx.SOGFUNC():  # n_funcs [mean1 sdev1 weight1 [mean2 sdev2 weight2 [...]]]
            funcType = 'SOGFUNC'
            n_funcs = int(str(ctx.Integer()))

            func['name'] = funcType
            func['n_funcs'] = n_funcs

            if n_funcs <= 0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} the number of Gaussian functions 'n_funcs={n_funcs}' must be a positive value.\n"
            elif ctx.Float(n_funcs * 3 - 1):
                func['mean'] = []
                func['sdev'] = []
                func['weight'] = []
                for n in range(n_funcs):
                    p = n * 3
                    mean = float(str(ctx.Float(p)))
                    sdev = float(str(ctx.Float(p + 1)))
                    weight = float(str(ctx.Float(p + 2)))

                    func['mean'].append(mean)
                    func['sdev'].append(sdev)
                    func['weight'].append(weight)

                    if n_funcs == 1:
                        func['target_value'] = mean
                        func['lower_limit'] = mean - sdev
                        func['upper_limit'] = mean + sdev

                    if sdev <= 0.0:
                        valid = False
                        self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                            f"{funcType} standard deviation 'sdev={sdev}' of {n+1}th function must be a positive value.\n"
                    if weight < 0.0:
                        valid = False
                        self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                            f"{funcType} 'weight={weight}' of {n+1}th function must not be a negative value.\n"
            else:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires consecutive 3 parameters (mean, sdev, weight) for each Gaussian function after the first 'n_funcs' value.\n"

        elif ctx.MIXTUREFUNC() or ctx.KARPLUS() or ctx.SOEDINGFUNC():
            if ctx.MIXTUREFUNC():  # anchor gaussian_param exp_param mixture_param bg_mean bg_sd
                funcType = 'MIXTUREFUNC'
                anchor = float(str(ctx.Float(0)))
                gaussian_param = float(str(ctx.Float(1)))
                exp_param = float(str(ctx.Float(2)))
                mixture_param = float(str(ctx.Float(3)))
                bg_mean = float(str(ctx.Float(4)))
                bg_sd = float(str(ctx.Float(5)))

                func['name'] = funcType
                func['anchor'] = anchor
                func['gaussian_param'] = gaussian_param
                func['exp_param'] = exp_param
                func['mixture_param'] = mixture_param
                func['bg_mean'] = bg_mean
                func['bg_sd'] = bg_sd

                if gaussian_param <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation of a Gaussian distribution 'gaussian_param={gaussian_param}' must be a positive value.\n"
                if exp_param <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} rate at which the exponential distribution drops off 'exp_param={exp_param}' must be a positive value.\n"
                if mixture_param <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} mixture of the Gaussian and Exponential functions 'mixture_param={mixture_param}' that make up g(r) function must be a positive value.\n"
                if bg_sd <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation 'bg_sd={bg_sd}' of h(r) function must be a positive value.\n"

            elif ctx.KARPLUS():  # A B C D x0 sd
                funcType = 'KARPLUS'
                A = float(str(ctx.Float(0)))
                B = float(str(ctx.Float(1)))
                C = float(str(ctx.Float(2)))
                D = float(str(ctx.Float(3)))
                x0 = float(str(ctx.Float(4)))
                sd = float(str(ctx.Float(5)))

                func['A'] = A
                func['B'] = B
                func['C'] = C
                func['D'] = D
                func['x0'] = x0
                func['sd'] = sd

                if sd <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation 'sd={sd}' must be a positive value.\n"

            else:  # w1 mean1 sd1 w2 mean2 sd2
                funcType = 'SOEDINGFUNC'
                w1 = float(str(ctx.Float(0)))
                mean1 = float(str(ctx.Float(1)))
                sd1 = float(str(ctx.Float(2)))
                w2 = float(str(ctx.Float(3)))
                mean2 = float(str(ctx.Float(4)))
                sd2 = float(str(ctx.Float(5)))

                func['w1'] = w1
                func['mean1'] = mean1
                func['sd1'] = sd1
                func['w2'] = w2
                func['mean2'] = mean2
                func['sd2'] = sd2

                if w1 < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} weight of the 1st Gaussian function 'w1={w1}' must not be a negative value.\n"
                if w2 < 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} weight of the 2nd Gaussian function 'w2={w2}' must not be a negative value.\n"
                if sd1 <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation of the 1st Gaussian function 'sd1={sd1}' must be a positive value.\n"
                if sd2 <= 0.0:
                    valid = False
                    self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                        f"{funcType} standard deviation of the 2nd Gaussian function 'sd2={sd2}' must be a positive value.\n"

        elif ctx.CONSTANTFUNC():  # return_val
            funcType = 'CONSTANTFUNC'
            return_val = float(str(ctx.Float(0)))

            func['name'] = funcType
            func['return_val'] = return_val

        elif ctx.IDENTITY():
            func['name'] = 'IDENTITY'

        elif ctx.SCALARWEIGHTEDFUNC():  # weight func_type_def
            funcType = 'SCALARWEIGHTEDFUNC'
            weight = float(str(ctx.Float(0)))

            func['name'] = funcType
            func['weight'] = weight

            if weight < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'weight={weight}' of {n+1}th function must not be a negative value.\n"

            func['func_types'] = []

        elif ctx.SUMFUNC():  # n_funcs Func_Type1 Func_Def1 [Func_Type2 Func_Def2 [...]]
            funcType = 'SUMFUNC'
            n_funcs = int(str(ctx.Integer()))

            func['name'] = funcType
            func['n_funcs'] = n_funcs

            if n_funcs <= 0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} the number of functions 'n_funcs={n_funcs}' must be a positive value.\n"
            elif ctx.func_type_def(n_funcs - 1):
                pass
            else:
                valid = False
                self.warningMessage += f"[Syntax error] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires {n_funcs} function definitions after the first 'n_funcs' value.\n"

            func['func_types'] = []

        elif ctx.SPLINE():  # description (NONE) experimental_value weight bin_size (x_axis val*)+
            funcType = 'SPLINE'
            description = str(ctx.Simple_name(0))
            experimental_value = float(str(ctx.Float(0)))
            weight = float(str(ctx.Float(1)))
            bin_size = float(str(ctx.Float(2)))

            func['name'] = funcType
            func['description'] = description
            func['experimental_value'] = experimental_value
            func['weight'] = weight
            func['bin_size'] = bin_size

            if weight < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'weight={weight}' must not be a negative value.\n"
            if bin_size <= 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'bin_size={bin_size}' must be a positive value.\n"

        elif ctx.FADE():  # lb ub d wd [ wo ]
            funcType = 'FADE'
            lb = float(str(ctx.Float(0)))
            ub = float(str(ctx.Float(1)))
            d = float(str(ctx.Float(2)))
            wd = float(str(ctx.Float(3)))
            wo = 0.0

            func['name'] = funcType
            func['lb'] = lb
            func['ub'] = ub
            func['d'] = d  # fade zone
            func['wd'] = wd  # well depth

            if lb > ub:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} lower boundary 'lb={lb}' must be less than or equal to upper boundary 'ub={ub}'.\n"

            if d < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} fade zone 'd={d}' must not be a negative value.\n"

            if ctx.Float(4):
                wo = float(str(ctx.Float(4)))

                func['wo'] = wo  # well add_offsetboxes

        elif ctx.SQUARE_WELL2():  # x0 width depth [DEGREES]
            funcType = 'SQUARE_WELL2'
            x0 = float(str(ctx.Float(0)))
            width = float(str(ctx.Float(2)))
            depth = float(str(ctx.Float(1)))

            func['name'] = funcType
            func['x0'] = x0
            func['width'] = width
            func['depth'] = depth

            if weight < 0.0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'weight={weight}' must not be a negative value.\n"

            if ctx.DEGREES():
                func['unit'] = 'degrees'
                func['lower_linear_limit'] = x0 - width
                func['upper_linear_limit'] = x0 + width
            else:
                func['unit'] = 'radians'
                func['lower_linear_limit'] = np.degrees(x0 - width)
                func['upper_linear_limit'] = np.degrees(x0 + width)

        elif ctx.ETABLE():  # min max [many numbers]
            funcType = 'ETABLE'
            min = float(str(ctx.Float(0)))
            max = float(str(ctx.Float(1)))

            func['name'] = funcType
            func['min'] = min
            func['max'] = max

            if min > max:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} 'min={min}' must be less than or equal to 'max={max}'.\n"

            if ctx.Float(2):
                pass
            else:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires parameters after the first 'min' and the second 'max' values.\n"

        elif ctx.USOG():  # num_gaussians mean1 sd1 mean2 sd2...
            funcType = 'USOG'
            num_gaussians = int(str(ctx.Integer()))

            func['name'] = funcType
            func['num_gaussians'] = num_gaussians

            if num_gaussians <= 0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} the number of Gaussian functions 'num_gaussians={num_gaussians}' must be a positive value.\n"
            elif ctx.Float(num_gaussians * 2 - 1):
                func['mean'] = []
                func['sd'] = []
                for n in range(num_gaussians):
                    p = n * 2
                    mean = float(str(ctx.Float(p)))
                    sd = float(str(ctx.Float(p + 1)))

                    func['mean'].append(mean)
                    func['sd'].append(sd)

                    if num_gaussians == 1:
                        func['target_value'] = mean
                        func['lower_limit'] = mean - sd
                        func['upper_limit'] = mean + sd

                    if sd <= 0.0:
                        valid = False
                        self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                            f"{funcType} standard deviation 'sd={sd}' of {n+1}th function must be a positive value.\n"
            else:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires consecutive 2 parameters (mean, sd) for each Gaussian function after the first 'num_gaussians' value.\n"

        elif ctx.SOG():  # num_gaussians mean1 sd1 weight1 mean2 sd2 weight2...
            funcType = 'SOG'
            num_gaussians = int(str(ctx.Integer()))

            func['name'] = funcType
            func['num_gaussians'] = num_gaussians

            if num_gaussians <= 0:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} the number of Gaussian functions 'num_gaussians={num_gaussians}' must be a positive value.\n"
            elif ctx.Float(num_gaussians * 3 - 1):
                func['mean'] = []
                func['sd'] = []
                func['weight'] = []
                for n in range(num_gaussians):
                    p = n * 3
                    mean = float(str(ctx.Float(p)))
                    sd = float(str(ctx.Float(p + 1)))
                    weight = float(str(ctx.Float(p + 2)))

                    func['mean'].append(mean)
                    func['sd'].append(sd)
                    func['weight'].append(weight)

                    if num_gaussians == 1:
                        func['target_value'] = mean
                        func['lower_limit'] = mean - sd
                        func['upper_limit'] = mean + sd

                    if sd <= 0.0:
                        valid = False
                        self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                            f"{funcType} standard deviation 'sd={sd}' of {n+1}th function must be a positive value.\n"
                    if weight < 0.0:
                        valid = False
                        self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                            f"{funcType} 'weight={weight}' of {n+1}th function must not be a negative value.\n"
            else:
                valid = False
                self.warningMessage += f"[Invalid data] {self.__getCurrentRestraint()}"\
                    f"{funcType} requires consecutive 3 parameters (mean, sd, weight) for each Gaussian function after the first 'num_gaussians' value.\n"

        if valid:
            self.stackFuncs.append(func)

    # Enter a parse tree produced by RosettaMRParser#rdc_restraints.
    def enterRdc_restraints(self, ctx: RosettaMRParser.Rdc_restraintsContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'rdc'

    # Exit a parse tree produced by RosettaMRParser#rdc_restraints.
    def exitRdc_restraints(self, ctx: RosettaMRParser.Rdc_restraintsContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#rdc_restraint.
    def enterRdc_restraint(self, ctx: RosettaMRParser.Rdc_restraintContext):  # pylint: disable=unused-argument
        self.rdcRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#rdc_restraint.
    def exitRdc_restraint(self, ctx: RosettaMRParser.Rdc_restraintContext):  # pylint: disable=unused-argument
        pass

    # Enter a parse tree produced by RosettaMRParser#disulfide_bond_linkages.
    def enterDisulfide_bond_linkages(self, ctx: RosettaMRParser.Disulfide_bond_linkagesContext):  # pylint: disable=unused-argument
        self.__cur_subtype = 'geo'

    # Exit a parse tree produced by RosettaMRParser#disulfide_bond_linkages.
    def exitDisulfide_bond_linkages(self, ctx: RosettaMRParser.Disulfide_bond_linkagesContext):
        pass

    # Enter a parse tree produced by RosettaMRParser#disulfide_bond_linkage.
    def enterDisulfide_bond_linkage(self, ctx: RosettaMRParser.Disulfide_bond_linkageContext):  # pylint: disable=unused-argument
        self.geoRestraints += 1

    # Exit a parse tree produced by RosettaMRParser#disulfide_bond_linkage.
    def exitDisulfide_bond_linkage(self, ctx: RosettaMRParser.Disulfide_bond_linkageContext):  # pylint: disable=unused-argument
        pass

    def __getCurrentRestraint(self):
        if self.__cur_subtype == 'dist':
            return f"[Check the {self.distRestraints}th row of distance restraints] "
        if self.__cur_subtype == 'ang':
            return f"[Check the {self.angRestraints}th row of angle restraints] "
        if self.__cur_subtype == 'dihed':
            return f"[Check the {self.dihedRestraints}th row of dihedral angle restraints] "
        if self.__cur_subtype == 'rdc':
            return f"[Check the {self.rdcRestraints}th row of residual dipolar coupling restraints] "
        if self.__cur_subtype == 'geo':
            return f"[Check the {self.geoRestraints}th row of coordinate geometry restraints] "
        return ''

    def getContentSubtype(self):
        """ Return content subtype of ROSETTA MR file.
        """

        contentSubtype = {'dist_restraint': self.distRestraints,
                          'ang_restraint': self.angRestraints,
                          'dihed_restraint': self.dihedRestraints,
                          'rdc_restraint': self.rdcRestraints,
                          'geo_restraint': self.geoRestraints
                          }

        return {k: 1 for k, v in contentSubtype.items() if v > 0}

    def getCoordAtomSite(self):
        """ Return coordinates' atom name dictionary of each residue.
        """
        return self.__coordAtomSite

    def getCoordUnobsRes(self):
        """ Return catalog of unobserved residues of the coordinates.
        """
        return self.__coordUnobsRes

# del RosettaMRParser
