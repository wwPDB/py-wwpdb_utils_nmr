# Generated from CcpnPKParser.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,37,316,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,1,0,3,0,20,8,0,1,0,1,0,1,0,1,0,5,0,26,8,0,10,0,
        12,0,29,9,0,1,0,1,0,1,1,3,1,34,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,3,1,45,8,1,1,1,1,1,3,1,49,8,1,1,1,3,1,52,8,1,1,1,3,1,55,8,
        1,1,1,3,1,58,8,1,1,1,3,1,61,8,1,1,1,3,1,64,8,1,1,1,3,1,67,8,1,1,
        1,1,1,4,1,71,8,1,11,1,12,1,72,1,2,3,2,76,8,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,1,2,1,2,3,2,89,8,2,1,2,1,2,3,2,93,8,2,1,2,3,2,96,
        8,2,1,2,3,2,99,8,2,1,2,3,2,102,8,2,1,2,5,2,105,8,2,10,2,12,2,108,
        9,2,1,2,1,2,1,3,3,3,113,8,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
        1,3,1,3,1,3,1,3,3,3,128,8,3,1,3,1,3,3,3,132,8,3,1,3,3,3,135,8,3,
        1,3,3,3,138,8,3,1,3,3,3,141,8,3,1,3,3,3,144,8,3,1,3,3,3,147,8,3,
        1,3,3,3,150,8,3,1,3,3,3,153,8,3,1,3,1,3,4,3,157,8,3,11,3,12,3,158,
        1,4,3,4,162,8,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,
        1,4,1,4,1,4,3,4,179,8,4,1,4,1,4,3,4,183,8,4,1,4,3,4,186,8,4,1,4,
        3,4,189,8,4,1,4,3,4,192,8,4,1,4,3,4,195,8,4,1,4,5,4,198,8,4,10,4,
        12,4,201,9,4,1,4,1,4,1,5,3,5,206,8,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
        1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,225,8,5,1,5,1,5,3,5,
        229,8,5,1,5,3,5,232,8,5,1,5,3,5,235,8,5,1,5,3,5,238,8,5,1,5,3,5,
        241,8,5,1,5,3,5,244,8,5,1,5,3,5,247,8,5,1,5,3,5,250,8,5,1,5,3,5,
        253,8,5,1,5,1,5,4,5,257,8,5,11,5,12,5,258,1,6,3,6,262,8,6,1,6,1,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
        6,1,6,3,6,283,8,6,1,6,1,6,3,6,287,8,6,1,6,3,6,290,8,6,1,6,3,6,293,
        8,6,1,6,3,6,296,8,6,1,6,3,6,299,8,6,1,6,3,6,302,8,6,1,6,5,6,305,
        8,6,10,6,12,6,308,9,6,1,6,1,6,1,7,1,7,1,8,1,8,1,8,0,0,9,0,2,4,6,
        8,10,12,14,16,0,7,2,0,2,2,13,13,2,0,14,14,18,18,2,0,15,15,19,19,
        1,1,10,10,2,0,16,16,20,20,2,0,17,17,21,21,2,0,3,5,8,8,368,0,19,1,
        0,0,0,2,33,1,0,0,0,4,75,1,0,0,0,6,112,1,0,0,0,8,161,1,0,0,0,10,205,
        1,0,0,0,12,261,1,0,0,0,14,311,1,0,0,0,16,313,1,0,0,0,18,20,5,10,
        0,0,19,18,1,0,0,0,19,20,1,0,0,0,20,27,1,0,0,0,21,26,3,2,1,0,22,26,
        3,6,3,0,23,26,3,10,5,0,24,26,5,10,0,0,25,21,1,0,0,0,25,22,1,0,0,
        0,25,23,1,0,0,0,25,24,1,0,0,0,26,29,1,0,0,0,27,25,1,0,0,0,27,28,
        1,0,0,0,28,30,1,0,0,0,29,27,1,0,0,0,30,31,5,0,0,1,31,1,1,0,0,0,32,
        34,5,1,0,0,33,32,1,0,0,0,33,34,1,0,0,0,34,35,1,0,0,0,35,44,7,0,0,
        0,36,37,7,1,0,0,37,38,7,2,0,0,38,39,5,22,0,0,39,45,5,23,0,0,40,41,
        5,22,0,0,41,42,5,23,0,0,42,43,7,1,0,0,43,45,7,2,0,0,44,36,1,0,0,
        0,44,40,1,0,0,0,45,46,1,0,0,0,46,48,5,26,0,0,47,49,5,27,0,0,48,47,
        1,0,0,0,48,49,1,0,0,0,49,51,1,0,0,0,50,52,5,28,0,0,51,50,1,0,0,0,
        51,52,1,0,0,0,52,54,1,0,0,0,53,55,5,29,0,0,54,53,1,0,0,0,54,55,1,
        0,0,0,55,57,1,0,0,0,56,58,5,32,0,0,57,56,1,0,0,0,57,58,1,0,0,0,58,
        60,1,0,0,0,59,61,5,33,0,0,60,59,1,0,0,0,60,61,1,0,0,0,61,63,1,0,
        0,0,62,64,5,34,0,0,63,62,1,0,0,0,63,64,1,0,0,0,64,66,1,0,0,0,65,
        67,5,35,0,0,66,65,1,0,0,0,66,67,1,0,0,0,67,68,1,0,0,0,68,70,5,37,
        0,0,69,71,3,4,2,0,70,69,1,0,0,0,71,72,1,0,0,0,72,70,1,0,0,0,72,73,
        1,0,0,0,73,3,1,0,0,0,74,76,5,3,0,0,75,74,1,0,0,0,75,76,1,0,0,0,76,
        77,1,0,0,0,77,88,5,3,0,0,78,79,3,14,7,0,79,80,3,14,7,0,80,81,5,8,
        0,0,81,82,5,8,0,0,82,89,1,0,0,0,83,84,5,8,0,0,84,85,5,8,0,0,85,86,
        3,14,7,0,86,87,3,14,7,0,87,89,1,0,0,0,88,78,1,0,0,0,88,83,1,0,0,
        0,89,90,1,0,0,0,90,92,3,16,8,0,91,93,3,16,8,0,92,91,1,0,0,0,92,93,
        1,0,0,0,93,95,1,0,0,0,94,96,3,14,7,0,95,94,1,0,0,0,95,96,1,0,0,0,
        96,98,1,0,0,0,97,99,3,14,7,0,98,97,1,0,0,0,98,99,1,0,0,0,99,101,
        1,0,0,0,100,102,3,14,7,0,101,100,1,0,0,0,101,102,1,0,0,0,102,106,
        1,0,0,0,103,105,5,8,0,0,104,103,1,0,0,0,105,108,1,0,0,0,106,104,
        1,0,0,0,106,107,1,0,0,0,107,109,1,0,0,0,108,106,1,0,0,0,109,110,
        7,3,0,0,110,5,1,0,0,0,111,113,5,1,0,0,112,111,1,0,0,0,112,113,1,
        0,0,0,113,114,1,0,0,0,114,127,7,0,0,0,115,116,7,1,0,0,116,117,7,
        2,0,0,117,118,7,4,0,0,118,119,5,22,0,0,119,120,5,23,0,0,120,128,
        5,24,0,0,121,122,5,22,0,0,122,123,5,23,0,0,123,124,5,24,0,0,124,
        125,7,1,0,0,125,126,7,2,0,0,126,128,7,4,0,0,127,115,1,0,0,0,127,
        121,1,0,0,0,128,129,1,0,0,0,129,131,5,26,0,0,130,132,5,27,0,0,131,
        130,1,0,0,0,131,132,1,0,0,0,132,134,1,0,0,0,133,135,5,28,0,0,134,
        133,1,0,0,0,134,135,1,0,0,0,135,137,1,0,0,0,136,138,5,29,0,0,137,
        136,1,0,0,0,137,138,1,0,0,0,138,140,1,0,0,0,139,141,5,30,0,0,140,
        139,1,0,0,0,140,141,1,0,0,0,141,143,1,0,0,0,142,144,5,32,0,0,143,
        142,1,0,0,0,143,144,1,0,0,0,144,146,1,0,0,0,145,147,5,33,0,0,146,
        145,1,0,0,0,146,147,1,0,0,0,147,149,1,0,0,0,148,150,5,34,0,0,149,
        148,1,0,0,0,149,150,1,0,0,0,150,152,1,0,0,0,151,153,5,35,0,0,152,
        151,1,0,0,0,152,153,1,0,0,0,153,154,1,0,0,0,154,156,5,37,0,0,155,
        157,3,8,4,0,156,155,1,0,0,0,157,158,1,0,0,0,158,156,1,0,0,0,158,
        159,1,0,0,0,159,7,1,0,0,0,160,162,5,3,0,0,161,160,1,0,0,0,161,162,
        1,0,0,0,162,163,1,0,0,0,163,178,5,3,0,0,164,165,3,14,7,0,165,166,
        3,14,7,0,166,167,3,14,7,0,167,168,5,8,0,0,168,169,5,8,0,0,169,170,
        5,8,0,0,170,179,1,0,0,0,171,172,5,8,0,0,172,173,5,8,0,0,173,174,
        5,8,0,0,174,175,3,14,7,0,175,176,3,14,7,0,176,177,3,14,7,0,177,179,
        1,0,0,0,178,164,1,0,0,0,178,171,1,0,0,0,179,180,1,0,0,0,180,182,
        3,16,8,0,181,183,3,16,8,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,
        1,0,0,0,184,186,3,14,7,0,185,184,1,0,0,0,185,186,1,0,0,0,186,188,
        1,0,0,0,187,189,3,14,7,0,188,187,1,0,0,0,188,189,1,0,0,0,189,191,
        1,0,0,0,190,192,3,14,7,0,191,190,1,0,0,0,191,192,1,0,0,0,192,194,
        1,0,0,0,193,195,3,14,7,0,194,193,1,0,0,0,194,195,1,0,0,0,195,199,
        1,0,0,0,196,198,5,8,0,0,197,196,1,0,0,0,198,201,1,0,0,0,199,197,
        1,0,0,0,199,200,1,0,0,0,200,202,1,0,0,0,201,199,1,0,0,0,202,203,
        7,3,0,0,203,9,1,0,0,0,204,206,5,1,0,0,205,204,1,0,0,0,205,206,1,
        0,0,0,206,207,1,0,0,0,207,224,7,0,0,0,208,209,7,1,0,0,209,210,7,
        2,0,0,210,211,7,4,0,0,211,212,7,5,0,0,212,213,5,22,0,0,213,214,5,
        23,0,0,214,215,5,24,0,0,215,225,5,25,0,0,216,217,5,22,0,0,217,218,
        5,23,0,0,218,219,5,24,0,0,219,220,5,25,0,0,220,221,7,1,0,0,221,222,
        7,2,0,0,222,223,7,4,0,0,223,225,7,5,0,0,224,208,1,0,0,0,224,216,
        1,0,0,0,225,226,1,0,0,0,226,228,5,26,0,0,227,229,5,27,0,0,228,227,
        1,0,0,0,228,229,1,0,0,0,229,231,1,0,0,0,230,232,5,28,0,0,231,230,
        1,0,0,0,231,232,1,0,0,0,232,234,1,0,0,0,233,235,5,29,0,0,234,233,
        1,0,0,0,234,235,1,0,0,0,235,237,1,0,0,0,236,238,5,30,0,0,237,236,
        1,0,0,0,237,238,1,0,0,0,238,240,1,0,0,0,239,241,5,31,0,0,240,239,
        1,0,0,0,240,241,1,0,0,0,241,243,1,0,0,0,242,244,5,32,0,0,243,242,
        1,0,0,0,243,244,1,0,0,0,244,246,1,0,0,0,245,247,5,33,0,0,246,245,
        1,0,0,0,246,247,1,0,0,0,247,249,1,0,0,0,248,250,5,34,0,0,249,248,
        1,0,0,0,249,250,1,0,0,0,250,252,1,0,0,0,251,253,5,35,0,0,252,251,
        1,0,0,0,252,253,1,0,0,0,253,254,1,0,0,0,254,256,5,37,0,0,255,257,
        3,12,6,0,256,255,1,0,0,0,257,258,1,0,0,0,258,256,1,0,0,0,258,259,
        1,0,0,0,259,11,1,0,0,0,260,262,5,3,0,0,261,260,1,0,0,0,261,262,1,
        0,0,0,262,263,1,0,0,0,263,282,5,3,0,0,264,265,3,14,7,0,265,266,3,
        14,7,0,266,267,3,14,7,0,267,268,3,14,7,0,268,269,5,8,0,0,269,270,
        5,8,0,0,270,271,5,8,0,0,271,272,5,8,0,0,272,283,1,0,0,0,273,274,
        5,8,0,0,274,275,5,8,0,0,275,276,5,8,0,0,276,277,5,8,0,0,277,278,
        3,14,7,0,278,279,3,14,7,0,279,280,3,14,7,0,280,281,3,14,7,0,281,
        283,1,0,0,0,282,264,1,0,0,0,282,273,1,0,0,0,283,284,1,0,0,0,284,
        286,3,16,8,0,285,287,3,16,8,0,286,285,1,0,0,0,286,287,1,0,0,0,287,
        289,1,0,0,0,288,290,3,14,7,0,289,288,1,0,0,0,289,290,1,0,0,0,290,
        292,1,0,0,0,291,293,3,14,7,0,292,291,1,0,0,0,292,293,1,0,0,0,293,
        295,1,0,0,0,294,296,3,14,7,0,295,294,1,0,0,0,295,296,1,0,0,0,296,
        298,1,0,0,0,297,299,3,14,7,0,298,297,1,0,0,0,298,299,1,0,0,0,299,
        301,1,0,0,0,300,302,3,14,7,0,301,300,1,0,0,0,301,302,1,0,0,0,302,
        306,1,0,0,0,303,305,5,8,0,0,304,303,1,0,0,0,305,308,1,0,0,0,306,
        304,1,0,0,0,306,307,1,0,0,0,307,309,1,0,0,0,308,306,1,0,0,0,309,
        310,7,3,0,0,310,13,1,0,0,0,311,312,7,6,0,0,312,15,1,0,0,0,313,314,
        7,6,0,0,314,17,1,0,0,0,60,19,25,27,33,44,48,51,54,57,60,63,66,72,
        75,88,92,95,98,101,106,112,127,131,134,137,140,143,146,149,152,158,
        161,178,182,185,188,191,194,199,205,224,228,231,234,237,240,243,
        246,249,252,258,261,282,286,289,292,295,298,301,306
    ]

class CcpnPKParser ( Parser ):

    grammarFileName = "CcpnPKParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Number'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'Position F1'", "'Position F2'", 
                     "'Position F3'", "'Position F4'", "'Shift F1'", "'Shift F2'", 
                     "'Shift F3'", "'Shift F4'", "'Assign F1'", "'Assign F2'", 
                     "'Assign F3'", "'Assign F4'", "'Height'", "'Volume'", 
                     "'Line Width F1 (Hz)'", "'Line Width F2 (Hz)'", "'Line Width F3 (Hz)'", 
                     "'Line Width F4 (Hz)'", "'Merit'", "'Details'", "'Fit Method'", 
                     "'Vol. Method'" ]

    symbolicNames = [ "<INVALID>", "Number", "Id", "Integer", "Float", "Real", 
                      "EXCLM_COMMENT", "SMCLN_COMMENT", "Simple_name", "SPACE", 
                      "RETURN", "SECTION_COMMENT", "LINE_COMMENT", "Id_", 
                      "Position_F1", "Position_F2", "Position_F3", "Position_F4", 
                      "Shift_F1", "Shift_F2", "Shift_F3", "Shift_F4", "Assign_F1", 
                      "Assign_F2", "Assign_F3", "Assign_F4", "Height", "Volume", 
                      "Line_width_F1", "Line_width_F2", "Line_width_F3", 
                      "Line_width_F4", "Merit", "Details", "Fit_method", 
                      "Vol_method", "SPACE_VARS", "RETURN_VARS" ]

    RULE_ccpn_pk = 0
    RULE_peak_list_2d = 1
    RULE_peak_2d = 2
    RULE_peak_list_3d = 3
    RULE_peak_3d = 4
    RULE_peak_list_4d = 5
    RULE_peak_4d = 6
    RULE_position = 7
    RULE_number = 8

    ruleNames =  [ "ccpn_pk", "peak_list_2d", "peak_2d", "peak_list_3d", 
                   "peak_3d", "peak_list_4d", "peak_4d", "position", "number" ]

    EOF = Token.EOF
    Number=1
    Id=2
    Integer=3
    Float=4
    Real=5
    EXCLM_COMMENT=6
    SMCLN_COMMENT=7
    Simple_name=8
    SPACE=9
    RETURN=10
    SECTION_COMMENT=11
    LINE_COMMENT=12
    Id_=13
    Position_F1=14
    Position_F2=15
    Position_F3=16
    Position_F4=17
    Shift_F1=18
    Shift_F2=19
    Shift_F3=20
    Shift_F4=21
    Assign_F1=22
    Assign_F2=23
    Assign_F3=24
    Assign_F4=25
    Height=26
    Volume=27
    Line_width_F1=28
    Line_width_F2=29
    Line_width_F3=30
    Line_width_F4=31
    Merit=32
    Details=33
    Fit_method=34
    Vol_method=35
    SPACE_VARS=36
    RETURN_VARS=37

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Ccpn_pkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CcpnPKParser.EOF, 0)

        def RETURN(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.RETURN)
            else:
                return self.getToken(CcpnPKParser.RETURN, i)

        def peak_list_2d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_list_2dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_list_2dContext,i)


        def peak_list_3d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_list_3dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_list_3dContext,i)


        def peak_list_4d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_list_4dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_list_4dContext,i)


        def getRuleIndex(self):
            return CcpnPKParser.RULE_ccpn_pk

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCcpn_pk" ):
                listener.enterCcpn_pk(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCcpn_pk" ):
                listener.exitCcpn_pk(self)




    def ccpn_pk(self):

        localctx = CcpnPKParser.Ccpn_pkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_ccpn_pk)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 19
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 18
                self.match(CcpnPKParser.RETURN)


            self.state = 27
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9222) != 0):
                self.state = 25
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                if la_ == 1:
                    self.state = 21
                    self.peak_list_2d()
                    pass

                elif la_ == 2:
                    self.state = 22
                    self.peak_list_3d()
                    pass

                elif la_ == 3:
                    self.state = 23
                    self.peak_list_4d()
                    pass

                elif la_ == 4:
                    self.state = 24
                    self.match(CcpnPKParser.RETURN)
                    pass


                self.state = 29
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 30
            self.match(CcpnPKParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_list_2dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Height(self):
            return self.getToken(CcpnPKParser.Height, 0)

        def RETURN_VARS(self):
            return self.getToken(CcpnPKParser.RETURN_VARS, 0)

        def Id(self):
            return self.getToken(CcpnPKParser.Id, 0)

        def Id_(self):
            return self.getToken(CcpnPKParser.Id_, 0)

        def Number(self):
            return self.getToken(CcpnPKParser.Number, 0)

        def Volume(self):
            return self.getToken(CcpnPKParser.Volume, 0)

        def Line_width_F1(self):
            return self.getToken(CcpnPKParser.Line_width_F1, 0)

        def Line_width_F2(self):
            return self.getToken(CcpnPKParser.Line_width_F2, 0)

        def Merit(self):
            return self.getToken(CcpnPKParser.Merit, 0)

        def Details(self):
            return self.getToken(CcpnPKParser.Details, 0)

        def Fit_method(self):
            return self.getToken(CcpnPKParser.Fit_method, 0)

        def Vol_method(self):
            return self.getToken(CcpnPKParser.Vol_method, 0)

        def peak_2d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_2dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_2dContext,i)


        def Assign_F1(self):
            return self.getToken(CcpnPKParser.Assign_F1, 0)

        def Assign_F2(self):
            return self.getToken(CcpnPKParser.Assign_F2, 0)

        def Position_F1(self):
            return self.getToken(CcpnPKParser.Position_F1, 0)

        def Shift_F1(self):
            return self.getToken(CcpnPKParser.Shift_F1, 0)

        def Position_F2(self):
            return self.getToken(CcpnPKParser.Position_F2, 0)

        def Shift_F2(self):
            return self.getToken(CcpnPKParser.Shift_F2, 0)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_list_2d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_list_2d" ):
                listener.enterPeak_list_2d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_list_2d" ):
                listener.exitPeak_list_2d(self)




    def peak_list_2d(self):

        localctx = CcpnPKParser.Peak_list_2dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_peak_list_2d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 32
                self.match(CcpnPKParser.Number)


            self.state = 35
            _la = self._input.LA(1)
            if not(_la==2 or _la==13):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 44
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14, 18]:
                self.state = 36
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 37
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 38
                self.match(CcpnPKParser.Assign_F1)
                self.state = 39
                self.match(CcpnPKParser.Assign_F2)
                pass
            elif token in [22]:
                self.state = 40
                self.match(CcpnPKParser.Assign_F1)
                self.state = 41
                self.match(CcpnPKParser.Assign_F2)
                self.state = 42
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 43
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 46
            self.match(CcpnPKParser.Height)
            self.state = 48
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27:
                self.state = 47
                self.match(CcpnPKParser.Volume)


            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 50
                self.match(CcpnPKParser.Line_width_F1)


            self.state = 54
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 53
                self.match(CcpnPKParser.Line_width_F2)


            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 56
                self.match(CcpnPKParser.Merit)


            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 59
                self.match(CcpnPKParser.Details)


            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 62
                self.match(CcpnPKParser.Fit_method)


            self.state = 66
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 65
                self.match(CcpnPKParser.Vol_method)


            self.state = 68
            self.match(CcpnPKParser.RETURN_VARS)
            self.state = 70 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 69
                self.peak_2d()
                self.state = 72 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_2dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Integer)
            else:
                return self.getToken(CcpnPKParser.Integer, i)

        def number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.NumberContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.NumberContext,i)


        def RETURN(self):
            return self.getToken(CcpnPKParser.RETURN, 0)

        def EOF(self):
            return self.getToken(CcpnPKParser.EOF, 0)

        def position(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.PositionContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.PositionContext,i)


        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Simple_name)
            else:
                return self.getToken(CcpnPKParser.Simple_name, i)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_2d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_2d" ):
                listener.enterPeak_2d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_2d" ):
                listener.exitPeak_2d(self)




    def peak_2d(self):

        localctx = CcpnPKParser.Peak_2dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_peak_2d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 74
                self.match(CcpnPKParser.Integer)


            self.state = 77
            self.match(CcpnPKParser.Integer)
            self.state = 88
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 78
                self.position()
                self.state = 79
                self.position()
                self.state = 80
                self.match(CcpnPKParser.Simple_name)
                self.state = 81
                self.match(CcpnPKParser.Simple_name)
                pass

            elif la_ == 2:
                self.state = 83
                self.match(CcpnPKParser.Simple_name)
                self.state = 84
                self.match(CcpnPKParser.Simple_name)
                self.state = 85
                self.position()
                self.state = 86
                self.position()
                pass


            self.state = 90
            self.number()
            self.state = 92
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 91
                self.number()


            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 94
                self.position()


            self.state = 98
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 97
                self.position()


            self.state = 101
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 100
                self.position()


            self.state = 106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==8:
                self.state = 103
                self.match(CcpnPKParser.Simple_name)
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 109
            _la = self._input.LA(1)
            if not(_la==-1 or _la==10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_list_3dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Height(self):
            return self.getToken(CcpnPKParser.Height, 0)

        def RETURN_VARS(self):
            return self.getToken(CcpnPKParser.RETURN_VARS, 0)

        def Id(self):
            return self.getToken(CcpnPKParser.Id, 0)

        def Id_(self):
            return self.getToken(CcpnPKParser.Id_, 0)

        def Number(self):
            return self.getToken(CcpnPKParser.Number, 0)

        def Volume(self):
            return self.getToken(CcpnPKParser.Volume, 0)

        def Line_width_F1(self):
            return self.getToken(CcpnPKParser.Line_width_F1, 0)

        def Line_width_F2(self):
            return self.getToken(CcpnPKParser.Line_width_F2, 0)

        def Line_width_F3(self):
            return self.getToken(CcpnPKParser.Line_width_F3, 0)

        def Merit(self):
            return self.getToken(CcpnPKParser.Merit, 0)

        def Details(self):
            return self.getToken(CcpnPKParser.Details, 0)

        def Fit_method(self):
            return self.getToken(CcpnPKParser.Fit_method, 0)

        def Vol_method(self):
            return self.getToken(CcpnPKParser.Vol_method, 0)

        def peak_3d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_3dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_3dContext,i)


        def Assign_F1(self):
            return self.getToken(CcpnPKParser.Assign_F1, 0)

        def Assign_F2(self):
            return self.getToken(CcpnPKParser.Assign_F2, 0)

        def Assign_F3(self):
            return self.getToken(CcpnPKParser.Assign_F3, 0)

        def Position_F1(self):
            return self.getToken(CcpnPKParser.Position_F1, 0)

        def Shift_F1(self):
            return self.getToken(CcpnPKParser.Shift_F1, 0)

        def Position_F2(self):
            return self.getToken(CcpnPKParser.Position_F2, 0)

        def Shift_F2(self):
            return self.getToken(CcpnPKParser.Shift_F2, 0)

        def Position_F3(self):
            return self.getToken(CcpnPKParser.Position_F3, 0)

        def Shift_F3(self):
            return self.getToken(CcpnPKParser.Shift_F3, 0)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_list_3d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_list_3d" ):
                listener.enterPeak_list_3d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_list_3d" ):
                listener.exitPeak_list_3d(self)




    def peak_list_3d(self):

        localctx = CcpnPKParser.Peak_list_3dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_peak_list_3d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 111
                self.match(CcpnPKParser.Number)


            self.state = 114
            _la = self._input.LA(1)
            if not(_la==2 or _la==13):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14, 18]:
                self.state = 115
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 116
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 117
                _la = self._input.LA(1)
                if not(_la==16 or _la==20):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 118
                self.match(CcpnPKParser.Assign_F1)
                self.state = 119
                self.match(CcpnPKParser.Assign_F2)
                self.state = 120
                self.match(CcpnPKParser.Assign_F3)
                pass
            elif token in [22]:
                self.state = 121
                self.match(CcpnPKParser.Assign_F1)
                self.state = 122
                self.match(CcpnPKParser.Assign_F2)
                self.state = 123
                self.match(CcpnPKParser.Assign_F3)
                self.state = 124
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 125
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 126
                _la = self._input.LA(1)
                if not(_la==16 or _la==20):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 129
            self.match(CcpnPKParser.Height)
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27:
                self.state = 130
                self.match(CcpnPKParser.Volume)


            self.state = 134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 133
                self.match(CcpnPKParser.Line_width_F1)


            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 136
                self.match(CcpnPKParser.Line_width_F2)


            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 139
                self.match(CcpnPKParser.Line_width_F3)


            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 142
                self.match(CcpnPKParser.Merit)


            self.state = 146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 145
                self.match(CcpnPKParser.Details)


            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 148
                self.match(CcpnPKParser.Fit_method)


            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 151
                self.match(CcpnPKParser.Vol_method)


            self.state = 154
            self.match(CcpnPKParser.RETURN_VARS)
            self.state = 156 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 155
                self.peak_3d()
                self.state = 158 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_3dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Integer)
            else:
                return self.getToken(CcpnPKParser.Integer, i)

        def number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.NumberContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.NumberContext,i)


        def RETURN(self):
            return self.getToken(CcpnPKParser.RETURN, 0)

        def EOF(self):
            return self.getToken(CcpnPKParser.EOF, 0)

        def position(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.PositionContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.PositionContext,i)


        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Simple_name)
            else:
                return self.getToken(CcpnPKParser.Simple_name, i)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_3d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_3d" ):
                listener.enterPeak_3d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_3d" ):
                listener.exitPeak_3d(self)




    def peak_3d(self):

        localctx = CcpnPKParser.Peak_3dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_peak_3d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 160
                self.match(CcpnPKParser.Integer)


            self.state = 163
            self.match(CcpnPKParser.Integer)
            self.state = 178
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 164
                self.position()
                self.state = 165
                self.position()
                self.state = 166
                self.position()
                self.state = 167
                self.match(CcpnPKParser.Simple_name)
                self.state = 168
                self.match(CcpnPKParser.Simple_name)
                self.state = 169
                self.match(CcpnPKParser.Simple_name)
                pass

            elif la_ == 2:
                self.state = 171
                self.match(CcpnPKParser.Simple_name)
                self.state = 172
                self.match(CcpnPKParser.Simple_name)
                self.state = 173
                self.match(CcpnPKParser.Simple_name)
                self.state = 174
                self.position()
                self.state = 175
                self.position()
                self.state = 176
                self.position()
                pass


            self.state = 180
            self.number()
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 181
                self.number()


            self.state = 185
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 184
                self.position()


            self.state = 188
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 187
                self.position()


            self.state = 191
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 190
                self.position()


            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 193
                self.position()


            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==8:
                self.state = 196
                self.match(CcpnPKParser.Simple_name)
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 202
            _la = self._input.LA(1)
            if not(_la==-1 or _la==10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_list_4dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Height(self):
            return self.getToken(CcpnPKParser.Height, 0)

        def RETURN_VARS(self):
            return self.getToken(CcpnPKParser.RETURN_VARS, 0)

        def Id(self):
            return self.getToken(CcpnPKParser.Id, 0)

        def Id_(self):
            return self.getToken(CcpnPKParser.Id_, 0)

        def Number(self):
            return self.getToken(CcpnPKParser.Number, 0)

        def Volume(self):
            return self.getToken(CcpnPKParser.Volume, 0)

        def Line_width_F1(self):
            return self.getToken(CcpnPKParser.Line_width_F1, 0)

        def Line_width_F2(self):
            return self.getToken(CcpnPKParser.Line_width_F2, 0)

        def Line_width_F3(self):
            return self.getToken(CcpnPKParser.Line_width_F3, 0)

        def Line_width_F4(self):
            return self.getToken(CcpnPKParser.Line_width_F4, 0)

        def Merit(self):
            return self.getToken(CcpnPKParser.Merit, 0)

        def Details(self):
            return self.getToken(CcpnPKParser.Details, 0)

        def Fit_method(self):
            return self.getToken(CcpnPKParser.Fit_method, 0)

        def Vol_method(self):
            return self.getToken(CcpnPKParser.Vol_method, 0)

        def peak_4d(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.Peak_4dContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.Peak_4dContext,i)


        def Assign_F1(self):
            return self.getToken(CcpnPKParser.Assign_F1, 0)

        def Assign_F2(self):
            return self.getToken(CcpnPKParser.Assign_F2, 0)

        def Assign_F3(self):
            return self.getToken(CcpnPKParser.Assign_F3, 0)

        def Assign_F4(self):
            return self.getToken(CcpnPKParser.Assign_F4, 0)

        def Position_F1(self):
            return self.getToken(CcpnPKParser.Position_F1, 0)

        def Shift_F1(self):
            return self.getToken(CcpnPKParser.Shift_F1, 0)

        def Position_F2(self):
            return self.getToken(CcpnPKParser.Position_F2, 0)

        def Shift_F2(self):
            return self.getToken(CcpnPKParser.Shift_F2, 0)

        def Position_F3(self):
            return self.getToken(CcpnPKParser.Position_F3, 0)

        def Shift_F3(self):
            return self.getToken(CcpnPKParser.Shift_F3, 0)

        def Position_F4(self):
            return self.getToken(CcpnPKParser.Position_F4, 0)

        def Shift_F4(self):
            return self.getToken(CcpnPKParser.Shift_F4, 0)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_list_4d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_list_4d" ):
                listener.enterPeak_list_4d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_list_4d" ):
                listener.exitPeak_list_4d(self)




    def peak_list_4d(self):

        localctx = CcpnPKParser.Peak_list_4dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_peak_list_4d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 204
                self.match(CcpnPKParser.Number)


            self.state = 207
            _la = self._input.LA(1)
            if not(_la==2 or _la==13):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 224
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14, 18]:
                self.state = 208
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 209
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 210
                _la = self._input.LA(1)
                if not(_la==16 or _la==20):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 211
                _la = self._input.LA(1)
                if not(_la==17 or _la==21):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 212
                self.match(CcpnPKParser.Assign_F1)
                self.state = 213
                self.match(CcpnPKParser.Assign_F2)
                self.state = 214
                self.match(CcpnPKParser.Assign_F3)
                self.state = 215
                self.match(CcpnPKParser.Assign_F4)
                pass
            elif token in [22]:
                self.state = 216
                self.match(CcpnPKParser.Assign_F1)
                self.state = 217
                self.match(CcpnPKParser.Assign_F2)
                self.state = 218
                self.match(CcpnPKParser.Assign_F3)
                self.state = 219
                self.match(CcpnPKParser.Assign_F4)
                self.state = 220
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 221
                _la = self._input.LA(1)
                if not(_la==15 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 222
                _la = self._input.LA(1)
                if not(_la==16 or _la==20):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 223
                _la = self._input.LA(1)
                if not(_la==17 or _la==21):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 226
            self.match(CcpnPKParser.Height)
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27:
                self.state = 227
                self.match(CcpnPKParser.Volume)


            self.state = 231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 230
                self.match(CcpnPKParser.Line_width_F1)


            self.state = 234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 233
                self.match(CcpnPKParser.Line_width_F2)


            self.state = 237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 236
                self.match(CcpnPKParser.Line_width_F3)


            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 239
                self.match(CcpnPKParser.Line_width_F4)


            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 242
                self.match(CcpnPKParser.Merit)


            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 245
                self.match(CcpnPKParser.Details)


            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 248
                self.match(CcpnPKParser.Fit_method)


            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 251
                self.match(CcpnPKParser.Vol_method)


            self.state = 254
            self.match(CcpnPKParser.RETURN_VARS)
            self.state = 256 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 255
                self.peak_4d()
                self.state = 258 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Peak_4dContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Integer)
            else:
                return self.getToken(CcpnPKParser.Integer, i)

        def number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.NumberContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.NumberContext,i)


        def RETURN(self):
            return self.getToken(CcpnPKParser.RETURN, 0)

        def EOF(self):
            return self.getToken(CcpnPKParser.EOF, 0)

        def position(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CcpnPKParser.PositionContext)
            else:
                return self.getTypedRuleContext(CcpnPKParser.PositionContext,i)


        def Simple_name(self, i:int=None):
            if i is None:
                return self.getTokens(CcpnPKParser.Simple_name)
            else:
                return self.getToken(CcpnPKParser.Simple_name, i)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_peak_4d

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeak_4d" ):
                listener.enterPeak_4d(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeak_4d" ):
                listener.exitPeak_4d(self)




    def peak_4d(self):

        localctx = CcpnPKParser.Peak_4dContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_peak_4d)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 260
                self.match(CcpnPKParser.Integer)


            self.state = 263
            self.match(CcpnPKParser.Integer)
            self.state = 282
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.state = 264
                self.position()
                self.state = 265
                self.position()
                self.state = 266
                self.position()
                self.state = 267
                self.position()
                self.state = 268
                self.match(CcpnPKParser.Simple_name)
                self.state = 269
                self.match(CcpnPKParser.Simple_name)
                self.state = 270
                self.match(CcpnPKParser.Simple_name)
                self.state = 271
                self.match(CcpnPKParser.Simple_name)
                pass

            elif la_ == 2:
                self.state = 273
                self.match(CcpnPKParser.Simple_name)
                self.state = 274
                self.match(CcpnPKParser.Simple_name)
                self.state = 275
                self.match(CcpnPKParser.Simple_name)
                self.state = 276
                self.match(CcpnPKParser.Simple_name)
                self.state = 277
                self.position()
                self.state = 278
                self.position()
                self.state = 279
                self.position()
                self.state = 280
                self.position()
                pass


            self.state = 284
            self.number()
            self.state = 286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 285
                self.number()


            self.state = 289
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 288
                self.position()


            self.state = 292
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 291
                self.position()


            self.state = 295
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.state = 294
                self.position()


            self.state = 298
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 297
                self.position()


            self.state = 301
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 300
                self.position()


            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==8:
                self.state = 303
                self.match(CcpnPKParser.Simple_name)
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 309
            _la = self._input.LA(1)
            if not(_la==-1 or _la==10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Float(self):
            return self.getToken(CcpnPKParser.Float, 0)

        def Real(self):
            return self.getToken(CcpnPKParser.Real, 0)

        def Integer(self):
            return self.getToken(CcpnPKParser.Integer, 0)

        def Simple_name(self):
            return self.getToken(CcpnPKParser.Simple_name, 0)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)




    def position(self):

        localctx = CcpnPKParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_position)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 312) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Float(self):
            return self.getToken(CcpnPKParser.Float, 0)

        def Real(self):
            return self.getToken(CcpnPKParser.Real, 0)

        def Integer(self):
            return self.getToken(CcpnPKParser.Integer, 0)

        def Simple_name(self):
            return self.getToken(CcpnPKParser.Simple_name, 0)

        def getRuleIndex(self):
            return CcpnPKParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = CcpnPKParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 312) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





